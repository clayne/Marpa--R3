@** Parse traverser code (TRV).
@ Pre-initialization is making the elements safe for the deallocation logic
to be called.  Often it is setting the value to zero, so that the deallocation
logic knows when {\bf not} to try deallocating a not-yet uninitialized value.
@s Marpa_Traverser int
@<Public incomplete structures@> =
struct marpa_traverser;
typedef struct marpa_traverser* Marpa_Traverser;
@ @<Private incomplete structures@> =
typedef struct marpa_traverser* TRAVERSER;
@ @<Traverser structure@> =
struct marpa_traverser {
    @<Widely aligned traverser elements@>@;
    @<Int aligned traverser elements@>@;
    @<Bit aligned traverser elements@>@;
};

@ @d YS_of_TRV(trv) ((trv)->t_trv_ys)
@d YIM_of_TRV(trv) ((trv)->t_trv_yim)
@<Widely aligned traverser elements@> =
YS t_trv_ys;
YIM t_trv_yim;

@ @<Initialize traverser elements@> =
YS_of_TRV(trv) = NULL;
YIM_of_TRV(trv) = NULL;

@ The un-reference of the recce also
releases the grammar.
@<Destroy traverser elements@> =
{
  recce_unref (R_of_TRV(trv));
  YS_of_TRV(trv) = NULL;
  YIM_of_TRV(trv) = NULL;
}

@ @d G_of_TRV(trv) ((trv)->t_grammar)
@d R_of_TRV(trv) ((trv)->t_recce)
@<Widely aligned traverser elements@> =
    GRAMMAR t_grammar;
    RECCE t_recce;

@ The reference to the recce also
holds the grammar.
@<Initialize traverser elements@> =
{
    R_of_TRV(trv) = r;
    recce_ref(g);
    G_of_TRV(trv) = G_of_R(r);
}

@ @<Set |end_of_parse_earley_set| and |end_of_parse_earleme|@> =

@*0 Traverser construction.
@<Function definitions@> =
Marpa_Traverser marpa_trv_new(Marpa_Recognizer r,
    Marpa_Earley_Set_ID es_arg,
    Marpa_Earley_Item_ID eim_arg
    )
{
    @<Return |NULL| on failure@>@;
    const GRAMMAR g = G_of_R(r);
    YS end_of_es;

    @<Fail if fatal error@>@;
    if (_MARPA_UNLIKELY( es_arg <= -2 ))
    {
        MARPA_ERROR(MARPA_ERR_INVALID_LOCATION);
        return failure_indicator;
    }

    @<Fail if recognizer not started@>@;

    if (G_is_Trivial(g)) {
        switch (es_arg) {
          default: goto NO_PARSE;
          case 0: case -1: break;
        }
        TRV_is_Nulling(trv) = 1;
        TRV_is_Trivial(trv) = 1;
        return trv;
    }

    r_update_earley_sets(r);
    {
      if (es_arg == -1)
	{
	  end_of_es = YS_at_Current_Earleme_of_R (r);
	}
      else
	{                           /* |ordinal_arg| != -1 */
	  if (!ES_Ord_is_Valid (r, es_arg))
	    {
	      MARPA_ERROR(MARPA_ERR_INVALID_LOCATION);
	      return failure_indicator;
	    }
	  end_of_es = YS_of_R_by_Ord (r, es_arg);
	}

      if (!end_of_es)
	goto NO_PARSE;
    }

    TODO check YIM argument !!!

    trv = my_malloc(sizeof(*trv));
    @<Initialize traverser elements@>@;

    return trv;
    NO_PARSE: ;
          MARPA_ERROR(MARPA_ERR_NO_PARSE);
    if (trv) {
        @<Destroy traverser elements@>;
    }
    return NULL;
}

@*0 Reference counting and destructors.
@ @<Int aligned traverser elements@>= int t_ref_count;
@ @<Initialize traverser elements@> =
trv->t_ref_count = 1;
@ Decrement the traverser reference count.
@<Function definitions@> =
PRIVATE void
traverser_unref (TRAVERSER trv)
{
  MARPA_ASSERT (trv->t_ref_count > 0)
  trv->t_ref_count--;
  if (trv->t_ref_count <= 0)
    {
      traverser_free(trv);
    }
}
void
marpa_trv_unref (Marpa_Traverser trv)
{
   traverser_unref(trv);
}

@ Increment the traverser reference count.
@<Function definitions@> =
PRIVATE TRAVERSER
traverser_ref (TRAVERSER trv)
{
  MARPA_ASSERT(trv->t_ref_count > 0)
  trv->t_ref_count++;
  return trv;
}
Marpa_Traverser
marpa_trv_ref (Marpa_Traverser trv)
{
   return traverser_ref(trv);
}

@*0 Traverser destruction.

@ This function is safe to call even
if the traverser already has been freed,
or was never initialized.
@<Function definitions@> =
PRIVATE void
traverser_free (TRAVERSER trv)
{
  @<Unpack traverser objects@>@;
  if (trv)
    {
      @<Destroy traverser elements@>;
    }
  my_free(trv);
}

@*0 Traverser is nulling?.
Is this traverser for a nulling parse?
@d TRV_is_Nulling(trv) ((trv)->t_is_nulling)
@ @<Bit aligned traverser elements@> =
BITFIELD t_is_nulling:1;
@ @<Initialize traverser elements@> =
TRV_is_Nulling(trv) = 0;
@ @<Function definitions@> =
int marpa_trv_is_null(Marpa_Traverser trv)
{
  @<Return |-2| on failure@>@;
  @<Unpack traverser objects@>@;
  @<Fail if fatal error@>@;
  return TRV_is_Nulling(trv);
}

