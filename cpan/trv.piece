@** Parse traverser code (TRV).
@ Pre-initialization is making the elements safe for the deallocation logic
to be called.  Often it is setting the value to zero, so that the deallocation
logic knows when {\bf not} to try deallocating a not-yet uninitialized value.
@s Marpa_Traverser int
@<Public incomplete structures@> =
struct marpa_traverser;
typedef struct marpa_traverser* Marpa_Traverser;
@ @<Private incomplete structures@> =
typedef struct marpa_traverser* TRAVERSER;
@ @<Traverser structure@> =
struct marpa_traverser {
    @<Widely aligned traverser elements@>@;
    @<Int aligned traverser elements@>@;
    @<Bit aligned traverser elements@>@;
};

@ @d YS_of_TRV(trv) ((trv)->t_trv_ys)
@d YIM_of_TRV(trv) ((trv)->t_trv_yim)
@<Widely aligned traverser elements@> =
YS t_trv_ys;
YIM t_trv_yim;

@ @<Initialize traverser elements@> =
YS_of_TRV(trv) = trv_ys;
YIM_of_TRV(trv) = trv_eim;

@ The un-reference of the recce also
releases the grammar.
@<Destroy traverser elements@> =
{
  recce_unref (R_of_TRV(trv));
  YS_of_TRV(trv) = NULL;
  YIM_of_TRV(trv) = NULL;
}

@ @d G_of_TRV(trv) ((trv)->t_grammar)
@d R_of_TRV(trv) ((trv)->t_recce)
@<Widely aligned traverser elements@> =
    GRAMMAR t_grammar;
    RECCE t_recce;

@ The reference to the recce also
holds the grammar.
@<Initialize traverser elements@> =
{
    R_of_TRV(trv) = r;
    recce_ref(g);
    G_of_TRV(trv) = G_of_R(r);
}

@*0 Traverser construction.
@<Function definitions@> =
Marpa_Traverser marpa_trv_new(Marpa_Recognizer r,
    Marpa_Earley_Set_ID es_arg,
    Marpa_Earley_Item_ID eim_arg
    )
{
    @<Return |NULL| on failure@>@;
    const GRAMMAR g = G_of_R(r);
    int item_count;
    YS trv_ys;
    YIM trv_eim;
    int trv_is_trivial = 0;

    @<Fail if fatal error@>@;
    if (_MARPA_UNLIKELY( es_arg <= -2 ))
    {
        MARPA_ERROR(MARPA_ERR_INVALID_LOCATION);
        return failure_indicator;
    }
    if (_MARPA_UNLIKELY( eim_arg <= 0 ))
    {
	MARPA_ERROR (MARPA_ERR_YIM_ID_INVALID);
        return failure_indicator;
    }

    @<Fail if recognizer not started@>@;

    if (G_is_Trivial(g)) {
        if (es_arg > 0) {
	    MARPA_ERROR(MARPA_ERR_INVALID_LOCATION);
	    return failure_indicator;
	}
        TRV_is_Trivial(trv) = 1;
    }

    r_update_earley_sets(r);
    if (es_arg == -1)
    {
      trv_ys = YS_at_Current_Earleme_of_R (r);
    }
    else
    {                           /* |ordinal_arg| != -1 */
	if (!ES_Ord_is_Valid (r, es_arg))
	{
	    MARPA_ERROR(MARPA_ERR_INVALID_LOCATION);
	    return failure_indicator;
	}
	trv_ys = YS_of_R_by_Ord (r, es_arg);
     }

    if (!trv_ys) {
	MARPA_ERROR (MARPA_ERR_INVALID_LOCATION);
	return failure_indicator;
    }
    item_count = YIM_Count_of_YS (earley_set);
    if (eim_arg >= item_count) {
	MARPA_ERROR (MARPA_ERR_YIM_ID_INVALID);
	return failure_indicator;
    }
    trv_yim = eim_arg;

    trv = my_malloc (sizeof (*trv));
    @<Initialize traverser elements@>@;
    trv->t_trv_ys = trv_ys;
    trv->t_trv_yim = trv_yim;
    return trv;
}

@*0 Reference counting and destructors.
@ @<Int aligned traverser elements@>= int t_ref_count;
@ @<Initialize traverser elements@> =
trv->t_ref_count = 1;
@ Decrement the traverser reference count.
@<Function definitions@> =
PRIVATE void
traverser_unref (TRAVERSER trv)
{
  MARPA_ASSERT (trv->t_ref_count > 0)
  trv->t_ref_count--;
  if (trv->t_ref_count <= 0)
    {
      traverser_free(trv);
    }
}
void
marpa_trv_unref (Marpa_Traverser trv)
{
   traverser_unref(trv);
}

@ Increment the traverser reference count.
@<Function definitions@> =
PRIVATE TRAVERSER
traverser_ref (TRAVERSER trv)
{
  MARPA_ASSERT(trv->t_ref_count > 0)
  trv->t_ref_count++;
  return trv;
}
Marpa_Traverser
marpa_trv_ref (Marpa_Traverser trv)
{
   return traverser_ref(trv);
}

@*0 Traverser destruction.

@ This function is safe to call even
if the traverser already has been freed,
or was never initialized.
@<Function definitions@> =
PRIVATE void
traverser_free (TRAVERSER trv)
{
  @<Unpack traverser objects@>@;
  if (trv)
    {
      @<Destroy traverser elements@>;
    }
  my_free(trv);
}

@*0 Traverser is trivial?.
Is this traverser for a trivial parse?
@d TRV_is_Trivial(trv) ((trv)->t_is_trivial)
@ @<Bit aligned traverser elements@> =
BITFIELD t_is_trivial:1;
@ @<Initialize traverser elements@> =
TRV_is_Trivial(trv) = 0;
@ @<Function definitions@> =
int marpa_trv_is_trivial(Marpa_Traverser trv)
{
  @<Return |-2| on failure@>@;
  @<Unpack traverser objects@>@;
  @<Fail if fatal error@>@;
  return TRV_is_Trivial(trv);
}

