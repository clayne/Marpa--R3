Recall the "open" question of whether there exists a grammar G which has
an ambiguous right recursion, but where G itself is unambiguous.  I think
the following proves the answer is no and wanted to ask if you agree.

I write <X> for symbols and <<sf>> for sentential forms.  I write Px(<X>,
<<Y>>) to say that the ordered set of parse trees Px have the symbols
in the sentential form <<X>> as their roots; and that the concatenation
of their fringes is <<Y>>.

Lemma:  Let G be a grammar; let <<b>> be a string of terminals in G and
let <B> be an accessible symbol in G.  Let P1(<B>, <<b>>) and P2(<B>,
<<b>>) be distinct parse trees.  Then G is ambiguous.

Proof:  Since <B> is accessible we know that there is a

1) PS(<S>, <<alpha>> <B> <<gamma>>)

such that <S> is the start symbol of G; <<alpha>> is a productive
sentential form in G; and <<gamma>> is a productive sentential form in G.
Therefore we also have Palpha and Pgamma such that there are strings of
terminals <<a>> and <<c>> where

2) Palpha(<<alpha>>, <<a>>) 3) Pgamma(<<gamma>>, <<c>>)

We assemble P1, PS, Palpha and Pgamma into single parse tree

4) PS1(<S>, <<a>> <<b>> <<c>>).

We assemble P2, PS, Palpha and Pgamma into single parse tree

5) PS2(<S>, <<a>> <<b>> <<c>>).

PS1 and PS2 are two distinct parse trees in G for the same sentence <<a>>
<<b>> <<c>>.  Therefore G is ambiguous.

QED for Lemma.

Now we observe that if G has an ambiguous right recursion in any parse
there exists accessible symbol <RR> and terminal string <<rr>> such that
Prr1(<RR>, <<rr>>) and Prr2(<RR>, <<rr>>).  It follows from the Lemma
that G is ambiguous.

QED.

I put "open" in quotes above because I suspect you had this result in
1991 and just didn't include it for reasons of space.  It's not really
a difficult result.  This would be why the only cases where you discuss
grammars which are unambiguous but non-linear for your algorithm are
those cases which involve middle recursions.


