-- Copyright 2016 Jeffrey Kegler
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the "Software"),
-- to deal in the Software without restriction, including without limitation
-- the rights to use, copy, modify, merge, publish, distribute, sublicense,
-- and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-- THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-- OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-- ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-- OTHER DEALINGS IN THE SOFTWARE.
--
-- [ MIT license: http://www.opensource.org/licenses/mit-license.php ]

-- The following is the description of the intended full argument syntax,
-- almost, all of which is *not* implement at present.  Arguments
-- have the form `key=value`, where key and value have no
-- internal spaces.  Allowed keys include
--     `in` -- where the value is an input file.
--     `out:section` -- where `section` is the name of a section
--          and the value is an output file.
--
-- If an argument does not contain an equal sign (`=`), the key `in`
-- is assumed and the argument is considered to be "abbreviated".  All
-- arguments after the first abbreviated argument are treated as abbreviated.
-- If an abbreviated argument contains an equal sign, so that it is
-- `section=file_name`, it is treated as if it was `out:section=file_name`.
--
-- The portion now implemented allows only "abbreviated" arguments,
-- and only one input argument.

require 'inspect' -- delete after development

local file_ids = {}

local outputs = {}
local inputs = {}

for arg_ix = 1,#arg do
    local this_arg = arg[arg_ix]
    if not this_arg:find("=") then
        inputs[#inputs+1] = this_arg
        goto NEXT_ARG
    end
    local section, file_name = this_arg:match("^([^=]+)%=(.*)") -- no space around =
    if not section or not file_name
            or #section < 1 or #file_name < 1 then
        error("Bad option: " .. this_arg)
    end
    outputs[section] = file_name
    ::NEXT_ARG::
end

if #inputs ~= 1 then
    error("There must be exactly one input file")
end

local sections = {}
local current_section
local current_subsection
local current_prefix

local input_handle
input_handle, error_message = io.open(inputs[1])
if not input_handle then error(error_message) end

-- We need random access to the input, so we incur the
-- cost of reading the entire input into memory.
local lines = {}
for line in input_handle:lines() do
    if line:find('\t') then error("line contains tab: " .. line) end
    if line:find(' $') then error("line has trailing space: " .. line) end
    lines[#lines+1] = line
end

-- Morphemes are the smallest meaningful pieces.  They
-- are instructions (which may be multi-line) and, otherwise,
-- individual lines.
local produce_lexeme = coroutine.wrap(
    function()
        local line_no = 0
        while true do
            line_no = line_no+1
            local line = lines[line_no]
            if not line then return end
            local prefix, equals = line:match('^(%s*)[-][-]%[(=)%[ *luatangle:')
            if prefix then
                if prefix:find('[^ ]') then
                    error(string.format(
                        'Problem in line %d: %s\n    Prefix must be all spaces',
                        line_no, line)
                    )
                end
                local first_line_no = line_no
                while line_no do
                    local line = lines[line_no]
                    if not line:sub(1, #prefix) ~= prefix then
                        error(string.format(
                            'Problem in line %d: %s\n'
                            .. '    Lines does not have prefix of %d spaces\n'
                            .. '    All lines of a long instruction must have its prefix\n',
                            line_no, line, #prefix
                            )
                        )
                    end
                    if line:match('%]' .. equals .. '%]') then
                        local instruction = parse_instruction(first_line_no, line_no)
                        coroutine.yield(instruction)
                        goto NEXT_LINE
                    end
                    line_no = line_no+1
                end
            end
            prefix = line:find('^(%s*)[-][-] *luatangle:')
            if prefix then
                local instruction = parse_instruction(line_no)
                coroutine.yield(instruction)
                goto NEXT_LINE
            end
            ::NEXT_LINE::
        end
    end
)

function look_for_text_run(first_line, ss_prefix)
    local end_of_run = nil
    local new_prefix = nil
    local current_line = first_line
    while current_line do
        local line = lines[current_line]
        -- an empty line is always part of the run
        if #line <= 0 then
            goto NEXT_LINE
        end
        -- a flush left line ends a run,
        -- and resets the prefix
        -- unless we already are flush left
        if #ss_prefix > 0 and not line:match('^[^ ]') then
            new_prefix = ''
            goto EMIT
        end
        -- if not flush left, but does not match the prefix,
        -- we have an error
        if line:sub(1, #ss_prefix) ~= ss_prefix then
            error(string.format('line does not have prefix of %d spaces: %s', #ss_prefix, line))
        end
        -- an instruction ends the text run,
        -- without resetting the prefix
        if line:match(instruction_pattern1) then
            goto EMIT
        end
        -- anything else is part of the run
        ::NEXT_LINE::
        end_of_run = line
        current_line = produce_line()
    end
    ::EMIT::
    if end_of_run then
        coroutine.yield({'run', first_line, end_of_run, ss_prefix})
    end
    return current_line, (new_prefix or ss_prefix)
end

function parse_section_name(raw_name)
    local text = raw_name:lower():gsub(' $', '', 1):gsub('^ ', '', 1):gsub('[^%w]+', ' ')
    return text
end

-- Rewrite non-alphanumerics to single space; remove initial space;
-- remove final space and lowercase the string
function parse_instruction(first_line_no, last_line_no)
    local raw_instruction = table.concat(lines, '', first_line_no, last_line_no)
    local prefix, body
    if last_line_no then
        local raw_instruction = table.concat(lines, '', first_line_no, last_line_no)
        local equals
        prefix, equals, body = raw_instruction.match('^( *)--(%[(=*)%[)? *luatangle: *(.*)$')
        body = body:gsub('%]' .. equals .. '%]$', '', 1)
    else
        local raw_instruction = lines[first_line_no]
        prefix, body = raw_instruction:match('^( *)-- *luatangle: *(.*)$')
    end
    -- print('raw_instruction', first_line_no, last_line_no, raw_instruction)
    local words = {}
    for word in body:gmatch('[%w%p]+') do
        words[#words+1] = word
    end
    -- print('words', inspect(words))
    local instruction = { first_line_no, last_line_no, prefix = prefix }
    if words[1] == 'section' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'section+' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'insert' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'end' and words[2] == 'section' then
        instruction.type = table.concat(words, ' ', 1, 2)
        return instruction
    end
    error(string.format(
        'Cannot parse instruction starting at line %d\n'
        .. '    Instruction begins: %s',
        first_line_no, lines[first_line_no]
    ))
end

-- Caller ensures that prefix is sane, but not that this actually is
-- an instruction
function look_for_long_instruction(first_line_no, ss_prefix)
    local current_line_no = first_line_no
    local first_line = lines[first_line_no]
    local instruction_prefix, comment_start =
        first_line:find('^([^-]*)--%[%[ *luatangle:')
    if not instruction_prefix then
        return first_line_no, ss_prefix
    end
    if not instruction_prefix:match('^ *$') then
        error(
            string.format('Problem in line %d: %s\n', first_line_no, first_line) ..
            '   Prefix of Miranda instruction must be all spaces\n'
        )
    end
    current_line = first_line
    end_of_instruction = nil
    while true do
        local _, end_of_brackets = line:find('%]%]')
        if line:find('%]%]') then
            if end_of_brackets ~= #line then
                error(
                    string.format('Problem in line %d: %s\n', current_line_no, current_line)
                        .. '    The closing brackets of a long instruction must end the line\n'
                        .. string.format('  Instruction started at line %d: %s\n', first_line_no, first_line)
                )
            end
            end_of_instruction = current_line_no
            break
        end
        current_line_no = produce_line()
        current_line = lines[current_line_no]
        if current_line:sub(1,#instruction_prefix) ~= instruction_prefix then
            error(
                string.format('Problem in line %d: %s\n', current_line_no, current_line)
                    .. '    Bad prefix -- all lines of an instruction must have the same prefix\n'
                    .. string.format('  Instruction started at line %d: %s\n', first_line_no, first_line)
            )
        end
    end
    if not end_of_instruction then
        error(
            string.format('Problem starting at line %d: %s\n', first_line_no, first_line) ..
                 '    Long instruction was never closed\n'
                 )
    end
    local raw_instruction = {}
    for line_no in first_line_no, end_of_instruction do
        raw_instruction[#raw_instruction+1] = lines[line_no]
    end
    instruction = parse_instruction(table.concat(raw_instruction))
    if not instruction then
        error(
            string.format('Unknown instruction starting at line %d: %s\n', first_line_no, first_line))
    end
    if instruction.type == 'section end' then
        new_prefix = ''
    end
    if instruction.type == 'section' then
        new_prefix = instruction_prefix
    end
    if instruction.type == 'section+' then
        new_prefix = instruction_prefix
    end
    coroutine.yield(instruction)
    return end_of_instruction+1, new_prefix
end

while true do
   local lexeme = produce_lexeme()
   if not lexeme then break end
   print(inspect(lexeme))
end

-- vim: expandtab shiftwidth=4:
