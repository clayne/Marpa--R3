-- Copyright 2016 Jeffrey Kegler
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the "Software"),
-- to deal in the Software without restriction, including without limitation
-- the rights to use, copy, modify, merge, publish, distribute, sublicense,
-- and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-- THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-- OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-- ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-- OTHER DEALINGS IN THE SOFTWARE.
--
-- [ MIT license: http://www.opensource.org/licenses/mit-license.php ]

-- The following is the description of the intended full argument syntax,
-- almost, all of which is *not* implement at present.  Arguments
-- have the form `key=value`, where key and value have no
-- internal spaces.  Allowed keys include
--     `in` -- where the value is an input file.
--     `out:section` -- where `section` is the name of a section
--          and the value is an output file.
--
-- If an argument does not contain an equal sign (`=`), the key `in`
-- is assumed and the argument is considered to be "abbreviated".  All
-- arguments after the first abbreviated argument are treated as abbreviated.
-- If an abbreviated argument contains an equal sign, so that it is
-- `section=file_name`, it is treated as if it was `out:section=file_name`.
--
-- The portion now implemented allows only "abbreviated" arguments,
-- and only one input argument.

require 'inspect' -- delete after development

local file_ids = {}

local outputs = {}
local inputs = {}

for arg_ix = 1,#arg do
    local this_arg = arg[arg_ix]
    if not this_arg:find("=") then
        inputs[#inputs+1] = this_arg
        goto NEXT_ARG
    end
    local section, file_name = this_arg:match("^([^=]+)%=(.*)") -- no space around =
    if not section or not file_name
            or #section < 1 or #file_name < 1 then
        error("Bad option: " .. this_arg)
    end
    outputs[section] = file_name
    ::NEXT_ARG::
end

if #inputs ~= 1 then
    error("There must be exactly one input file")
end

local sections = {}
local current_section
local current_subsection
local current_prefix

local input_handle
input_handle, error_message = io.open(inputs[1])
if not input_handle then error(error_message) end

-- We need random access to the input, so we incur the
-- cost of reading the entire input into memory.
local lines = {}
for line in input_handle:lines() do
    if line:find('\t') then error("line contains tab: " .. line) end
    if line:find(' $') then error("line has trailing space: " .. line) end
    lines[#lines+1] = line
end

local function problem_in_line(line_no)
     return string.format("Problem in line %d: %s\n", line_no, lines[line_no])
end

-- Morphemes are the smallest meaningful pieces.  They
-- are instructions (which may be multi-line) and, otherwise,
-- individual lines.
local function instruction_iter()
    return  coroutine.wrap(
        function()
            local line_no = 0
                while true do
                    line_no = line_no+1
                    local line = lines[line_no]
                    if not line then return end
                    local prefix, equals = line:match('^(%s*)[-][-]%[(=)%[ *luatangle:')
                    if prefix then
                        if prefix:find('[^ ]') then
                            error(string.format(
                                'Problem in line %d: %s\n    Prefix must be all spaces',
                                line_no, line)
                            )
                        end
                        local first_line_no = line_no
                        while line_no do
                            local line = lines[line_no]
                            if not line:sub(1, #prefix) ~= prefix then
                                error(string.format(
                                    'Problem in line %d: %s\n'
                                    .. '    Lines does not have prefix of %d spaces\n'
                                    .. '    All lines of a long instruction must have its prefix\n',
                                    line_no, line, #prefix
                                    )
                                )
                            end
                            if line:match('%]' .. equals .. '%]') then
                                local instruction = parse_instruction(first_line_no, line_no)
                                coroutine.yield(instruction)
                                goto NEXT_LINE
                            end
                            line_no = line_no+1
                        end
                    end
                    prefix = line:find('^(%s*)[-][-] *luatangle:')
                    if prefix then
                        local instruction = parse_instruction(line_no)
                        coroutine.yield(instruction)
                        goto NEXT_LINE
                    end
                ::NEXT_LINE::
            end
        end
    )
end

function look_for_text_run(first_line, ss_prefix)
    local end_of_run = nil
    local new_prefix = nil
    local current_line = first_line
    while current_line do
        local line = lines[current_line]
        -- an empty line is always part of the run
        if #line <= 0 then
            goto NEXT_LINE
        end
        -- a flush left line ends a run,
        -- and resets the prefix
        -- unless we already are flush left
        if #ss_prefix > 0 and not line:match('^[^ ]') then
            new_prefix = ''
            goto EMIT
        end
        -- if not flush left, but does not match the prefix,
        -- we have an error
        if line:sub(1, #ss_prefix) ~= ss_prefix then
            error(string.format('line does not have prefix of %d spaces: %s', #ss_prefix, line))
        end
        -- an instruction ends the text run,
        -- without resetting the prefix
        if line:match(instruction_pattern1) then
            goto EMIT
        end
        -- anything else is part of the run
        ::NEXT_LINE::
        end_of_run = line
        current_line = produce_line()
    end
    ::EMIT::
    if end_of_run then
        coroutine.yield({'run', first_line, end_of_run, ss_prefix})
    end
    return current_line, (new_prefix or ss_prefix)
end

function parse_section_name(raw_name)
    local text = raw_name:lower():gsub(' $', '', 1):gsub('^ ', '', 1):gsub('[^%w]+', ' ')
    return text
end

local mt_instruction = {
     last_line = function(instruction) return instruction[2] or instruction[1] end
}

-- Rewrite non-alphanumerics to single space; remove initial space;
-- remove final space and lowercase the string
function parse_instruction(first_line_no, last_line_no)
    local raw_instruction = table.concat(lines, '', first_line_no, last_line_no)
    local prefix, body
    if last_line_no then
        local raw_instruction = table.concat(lines, '', first_line_no, last_line_no)
        local equals
        prefix, equals, body = raw_instruction.match('^( *)--(%[(=*)%[)? *luatangle: *(.*)$')
        body = body:gsub('%]' .. equals .. '%]$', '', 1)
    else
        local raw_instruction = lines[first_line_no]
        prefix, body = raw_instruction:match('^( *)-- *luatangle: *(.*)$')
    end
    -- print('raw_instruction', first_line_no, last_line_no, raw_instruction)
    local words = {}
    for word in body:gmatch('[%w%p]+') do
        words[#words+1] = word
    end
    -- print('words', inspect(words))
    local instruction = { first_line_no, last_line_no, prefix = prefix }
    setmetatable(instruction, mt_instruction)
    if words[1] == 'section' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'section+' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'insert' then
        instruction.type = words[1]
        instruction.name = parse_section_name(table.concat(words, ' ', 2))
        return instruction
    end
    if words[1] == 'end' and words[2] == 'section' then
        instruction.type = table.concat(words, ' ', 1, 2)
        return instruction
    end
    error(string.format(
        'Cannot parse instruction starting at line %d\n'
        .. '    Instruction begins: %s',
        first_line_no, lines[first_line_no]
    ))
end

-- Caller ensures that prefix is sane, but not that this actually is
-- an instruction
function look_for_long_instruction(first_line_no, ss_prefix)
    local current_line_no = first_line_no
    local first_line = lines[first_line_no]
    local instruction_prefix, comment_start =
        first_line:find('^([^-]*)--%[%[ *luatangle:')
    if not instruction_prefix then
        return first_line_no, ss_prefix
    end
    if not instruction_prefix:match('^ *$') then
        error(
            string.format('Problem in line %d: %s\n', first_line_no, first_line) ..
            '   Prefix of Miranda instruction must be all spaces\n'
        )
    end
    current_line = first_line
    end_of_instruction = nil
    while true do
        local _, end_of_brackets = line:find('%]%]')
        if line:find('%]%]') then
            if end_of_brackets ~= #line then
                error(
                    string.format('Problem in line %d: %s\n', current_line_no, current_line)
                        .. '    The closing brackets of a long instruction must end the line\n'
                        .. string.format('  Instruction started at line %d: %s\n', first_line_no, first_line)
                )
            end
            end_of_instruction = current_line_no
            break
        end
        current_line_no = produce_line()
        current_line = lines[current_line_no]
        if current_line:sub(1,#instruction_prefix) ~= instruction_prefix then
            error(
                string.format('Problem in line %d: %s\n', current_line_no, current_line)
                    .. '    Bad prefix -- all lines of an instruction must have the same prefix\n'
                    .. string.format('  Instruction started at line %d: %s\n', first_line_no, first_line)
            )
        end
    end
    if not end_of_instruction then
        error(
            string.format('Problem starting at line %d: %s\n', first_line_no, first_line) ..
                 '    Long instruction was never closed\n'
                 )
    end
    local raw_instruction = {}
    for line_no in first_line_no, end_of_instruction do
        raw_instruction[#raw_instruction+1] = lines[line_no]
    end
    instruction = parse_instruction(table.concat(raw_instruction))
    if not instruction then
        error(
            string.format('Unknown instruction starting at line %d: %s\n', first_line_no, first_line))
    end
    if instruction.type == 'section end' then
        new_prefix = ''
    end
    if instruction.type == 'section' then
        new_prefix = instruction_prefix
    end
    if instruction.type == 'section+' then
        new_prefix = instruction_prefix
    end
    coroutine.yield(instruction)
    return end_of_instruction+1, new_prefix
end

local instructions = {}
for instruction in instruction_iter() do
    print(inspect(instruction))
    instructions[#instructions+1] = instruction
end

local function next_run_find(instruction_ix)
    while true do
        local instruction = instructions[instruction_ix]
        if not instruction then return nil end
        if type == 'section' then
            local run_name = instruction.name
            local section = sections[run_name]
            if not section then return instruction_ix end
            error(problem_in_line(instruction:first_line())
                .. "   'section' command, but section already exists\n"
                .. "   A 'section' command must start a new section\n"
            )
        end
        if type == 'section+' then
            local run_name = instruction.name
            local section = sections[run_name]
            if section then return instruction_ix end
            error(problem_in_line(instruction:first_line())
                .. "   'section+' command, but section does not exist\n"
                .. "   A 'section+' command must continue an existing section\n"
            )
        end

        -- Currently no instruction are allowed outside a run -- they
        -- must either start a run or occur within one.
        error(problem_in_line(instruction:first_line())
            .. string.format("   '%s' command is only allowed inside a run\n",
                 type)
        )
    end
    return nil
end


-- A "run" is a series of consecutive lines which end up in a
-- section.  A section consists 1 or more runs.
local function run_iter()
    return  coroutine.wrap(
        function()
            local run_name = nil
            local run_prefix = nil
            local current_line_no = nil
            local start_instruction_ix = 1
            -- while we can find start instructions
            while true do
                local start_instruction_ix = next_run_find(start_instruction_ix)
                if not start_instruction_ix then return nil end
                local start_instruction = instructions[start_instruction_ix]
                local run_name = start_instruction.name
                local run_prefix = start_instruction.prefix
                local current_instruction_ix = start_instruction_ix
                while true do
                    local current_instruction = instructions[current_instruction_ix]
                    local next_instruction = instructions[current_instruction_ix+1]
                    local first_text_line = current_instruction:last_line() + 1
                    local last_text_line = next_instruction and next_instruction:first_line()-1 or #lines
                    local end_of_run = nil
                    for text_line_no = first_text_line, last_text_line do
                        local line = lines[text_line_no]
                        if #line > 0 and line:sub(1, #run_prefix) ~= run_prefix then
                            end_of_run = text_line_no
                            break
                        end
                    end
                    if end_of_run then
                        coroutine.yield(start_instruction, end_of_run)
                        start_instruction_ix = current_instruction_ix + 1
                        goto NEXT_RUN
                    end
                    if not next_instruction then
                        coroutine.yield(start_instruction, #lines)
                    end
                    local next_instruction_line_no = next_instruction:first_line()
                    if next_instruction_line_no:sub(1, #run_prefix) ~= run_prefix then
                        coroutine.yield(start_instruction, next_instruction_line_no-1)
                        start_instruction_ix = current_instruction_ix + 1
                        goto NEXT_RUN
                    end
                    if next_instruction.type == "end section" then
                        coroutine.yield(start_instruction, next_instruction:last_line())
                        start_instruction_ix = current_instruction_ix + 2
                        goto NEXT_RUN
                    end
                    current_instruction_ix = current_instruction_ix + 1
                end
                ::NEXT_RUN::
            end
        end
    )
end

-- vim: expandtab shiftwidth=4:
