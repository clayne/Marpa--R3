# Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.
#
# This module is free software; you can redistribute it and/or modify it
# under the same terms as Perl 5.10.1. For more details, see the full text
# of the licenses in the directory LICENSES.
#
# This program is distributed in the hope that it will be
# useful, but it is provided "as is" and without any express
# or implied warranties. For details, see the full text of
# of the licenses in the directory LICENSES.

=head1 NAME

Marpa::R3::Semantics::Rank - How ranks are computed

=head1 Synopsis

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1

    my $source = <<'END_OF_SOURCE';
      :discard ~ ws; ws ~ [\s]+
      :default ::= action => ::array
      
      Top ::= List action => main::group
      List ::= Item3 rank => 6
      List ::= Item2 rank => 5
      List ::= Item1 rank => 4
      List ::= List Item3 rank => 3
      List ::= List Item2 rank => 2
      List ::= List Item1 rank => 1
      Item3 ::= VAR '=' VAR rank => 3 action => main::concat
      Item2 ::= VAR '='     rank => 2 action => main::concat
      Item1 ::= VAR         rank => 1 action => main::concat
      VAR ~ [\w]+

    END_OF_SOURCE

    my @tests = (
        [ 'a = b',             '(a=b)', ],
        [ 'a = b c = d',       '(a=b)(c=d)' ],
        [ 'a = b c = d e',     '(a=b)(c=d)(e)' ],
        [ 'a = b c = d e =',   '(a=b)(c=d)(e=)' ],
        [ 'a = b c = d e = f', '(a=b)(c=d)(e=f)' ],
    );

    my $grammar = Marpa::R3::Grammar->new(
        { ranking_method => 'high_rule_only', source => \$source } );
    for my $test (@tests) {
        my ( $input, $output ) = @{$test};
        my $recce = Marpa::R3::Recognizer->new( { grammar => $grammar } );
        $recce->read( \$input );
        my $value_ref = $recce->value();
        if ( not defined $value_ref ) {
            die 'No parse';
        }
        push @results, ${$value_ref};
    }

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: rank example semantics
normalize-whitespace: 1

    sub flatten {
        my ($array) = @_;

        # say STDERR 'flatten arg: ', Data::Dumper::Dumper($array);
        my $ref = ref $array;
        return [$array] if $ref ne 'ARRAY';
        my @flat = ();
      ELEMENT: for my $element ( @{$array} ) {
            my $ref = ref $element;
            if ( $ref ne 'ARRAY' ) {
                push @flat, $element;
                next ELEMENT;
            }
            my $flat_piece = flatten($element);
            push @flat, @{$flat_piece};
        }
        return \@flat;
    }

    sub concat {
        my ( $pp, @args ) = @_;

        # say STDERR 'concat: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', @{$flat};
    }

    sub group {
        my ( $pp, @args ) = @_;

        # say STDERR 'comma_sep args: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', map { +'(' . $_ . ')'; } @{$flat};
    }

=for Marpa::R3::Display::End

=head1 Description

This document describes rule ranking.
Rule ranking plays a role in parse ordering,
which is descibed in L<a separate
document|Marpa::R3::Semantics::Order>.
Rule ranking has its own document,
because it merits careful definition,
and so that multiple examples can be given.

=head1 Dotted Productions

To understand this document,
it is important to understand what a dotted production is.
An acquaintance with
dotted productions is also important in understanding
Marpa's progress reports,
and dotted productions
are thoroughly described
L<in the progress report
documentation|Marpa::R3::Progress>.
This section repeats the main ideas
from the perspective of this document.

Recall that a production is a B<LHS> (left hand side)
and a B<RHS> (right hand side).
The B<LHS> is always exactly one symbol.
The B<RHS> is zero or more symbols.
Consider the following example of a production,
given in the syntax of Marpa's DSL.

=for Marpa::R3::Display
ignore: 1

    S ::= A B C

=for Marpa::R3::Display

Dotted productions are used to track the
progress of a parse through a production.
They consist of a production and a B<dot location>,
which marks the point in the RHS which scanning
has reached.
It is called the B<dot location> because,
traditionally,
the location is represented by a dot.
The symbol before the dot is called
the B<predot symbol>.

The following is an example of a dotted production.
(The dot of a dotted rule is not part of Marpa DSL's,
but we will add it in this document for the sake
of illustration.)

=for Marpa::R3::Display
ignore: 1

    S ::= A B . C

=for Marpa::R3::Display

In this production, B<B> is the B<predot symbol>.

When the dot is after the last symbol of the RHS,
the dotted production is called a B<completion>.
Here is the completion for the above production:

=for Marpa::R3::Display
ignore: 1

    S ::= A B C .

=for Marpa::R3::Display

In this completion example, the symbol B<C>
is the predot symbol.

When the dot is before the first symbol of the RHS,
the production is called a B<prediction>.
Here is the prediction of the production we've been
using for our examples:

=for Marpa::R3::Display
ignore: 1

    S ::= . A B C

=for Marpa::R3::Display

In predictions, there is no predot symbol.

=head1 Choicepoints

Informally
a B<choicepoint> is a place where the parser
can decide among B<parse choices>.
A choicepoint can be thought of either a set
of parse choices,
or as the tuple of the properties which all
the parse choices for the choicepoint
must have in common.

For a choicepoint to work, all the choices must
have enough in common that each of them
could be replaced with any other.
Thought of as a tuple of properties,
a choicepoint is a triple: C<(dp, start, current)>.
In this triple,

=over 4

=item *

C<dp> is a dotted production.
In a choicepoint, C<dp> is never a prediction,
and therefore there is always a predot symbol.
The predot symbol of C<dp>
is the B<predot symbol> of the choicepoint;
the production of C<dp>
is the B<production> of the choicepoint;
and the
dot position of C<dp>
is the B<dot position> of the choicepoint.

=item *

C<start> is the G1 location where the dotted
production begins.
C<start> is sometimes called the B<origin> of the
choicepoint.

=item *

C<current> is the G1 location corresponding to the dot
in C<dp>.
C<current> is sometimes 
called the C<current position> of the choicepoint.

=back

The choicepoint is a token choicepoint if the
predot symbol of C<dp> is a token symbol.
The choicepoint is a production choicepoint if the
predot symbol of C<dp> is the LHS of a production.
(Token symbols are never the LHS of a production,
and vice versa.)

=head1 Parse choices

As mentioned, a choicepoint can be seen as a set
of one or more B<parse choices>.
From the point of view of the individual parse trees,
the traversal is top-down
and left-to-right.

Often, there is only one parse choice.
When there is only one parse choice,
the choicepoint is said to be B<trivial>.
If all of the choicepoints of a parse
are trivial,
the parse is unambiguous.

A parse choice is a duple: C<(predecessor, cause)>.
The first element of the duple is the B<predecessor>
of the parse choice.
The second element of the duple is the B<cause>
of the parse choice.

Every parse choice has a distinct cause.
In every parse choice of a token choicepoint, C<cause> is a token symbol.
A token choicepoint is always trivial --
this is, it always has exactly one parse choice.

A production choicepoint may have many parse choices.
In every parse choice of a production choicepoint,
C<cause> is another choicepoint,
called the B<cause choicepoint>.

If C<cp-prod> is production choicepoint
and C<cp-cuz> is the cause of one of the parse choices,
then we say that C<cp-prod> is the B<result>
of C<cp-cuz>;
and we say that C<cp-cuz> is one of the B<causes>
of C<cp-prod>.

The predecessor of a parse choice
is a choicepoint that
represents a portion
of the parse that "leads up to" the cause.
The predecessor
element of a parse choice plays no role in ranking
decisions,
and this document will mostly ignore predecessors.

=head1 Causes

Since it is a choicepoint, a cause choicepoint
must also be a triple.
Let the triple for for C<cp-cuz> be C<(cuz-dp, cuz-origin, cuz-current)>.
Let the result of C<cp-cuz> be
C<cp-prod> and
let the
triple for for C<cp-prod> be C<(prod-dp, prod-origin, prod-current)>.

If C<cp-prod> is the result of C<cp-cuz>, then

=over 4

=item *

C<cuz-current> is always the same as
C<prod-current>.
In other words,
the current location of C<cp-cuz>
is the same as the current location of C<cp-prod>.

=item *

C<cuz-origin> is before C<prod-current>.
In other words,
the origin of C<cp-cuz>
is before the current location of C<cp-prod>.

=item *

C<cuz-origin>
is at or after C<prod-origin>.
In other words,
the origin of C<cp-cuz>
is at or after the origin of C<cp-prod>.
While it is not always properly between
C<prod-origin> and C<prod-current>,
C<cuz-origin> is always in the range bounded
by 
C<prod-origin> on one side,
and C<prod-current> and C<cuz-current>
on the other.
C<cuz-origin>
can therefore be thought of as "in the middle"
of the parse choice.
For this reason,
C<cuz-origin> is often called the
B<middle location> of the parse choice.

=item *

The dotted production of C<cp-cuz> will be a completion.

=item *

The LHS of the dotted production of C<cp-cuz> will be
the predot symbol of C<cp-prod>.

=back

Summing up the above,
the causes of a production choicepoint
vary only by
middle position
and production RHS.
The causes of a production choicepoint
always share the same current G1 location
and production LHS,
and their dotted productions
are always completions.

=head1 Rule Rank

The rank of a parse choice is that of its cause.
If the cause is a token,
the rank of the choice is the rank of the token symbol.
If the cause is a choicepoint,
the rank of the parse choice
is the rank of the production of the cause.
Since a token choicepoint is always trivial,
we can say:

B<The rank of a non-trivial parse choice is the rank
of the production of its cause.>

=head1 Motivation

For the purposes of this section,
let C<result> be a production choicepoint:
let the "result-production" be the production of C<result>;
and let the "cause-productions" be the productions
of the causes of C<result>.
By the definition of the previous section,
the result-production plays no role in ranking
the parse choices of C<result>.
Instead,
the parse choices of C<result> are ranked by
the cause-productions.
At first,
this may seem unnecessarily roundabout,
and even counter-intuitive.

On reflection,
the above definition makes sense,
because all parse choices
in the C<result> choicepoint
share the same result-production,
so that the result-production cannot be
a useful part of a ranking method.
On the other hand,
parse choices often
differ in their cause-productions,
so that cause-productions can be very helpful in
producing a useful ranking method.

Note that ranking is only by direct causes.
That is the cause-productions determine the rank,
but even if there is a tie in the rank of the cause-productions,
the rank of any productions derived from the cause choicepoints
is B<not> considered.

It might be useful to have a scheme that
allows ranking to be inherited.
But such a scheme would be complex,
and would require recursion to implement.
Marpa's built-in production ranking
was chosen to be the most powerful system
that could be implemented with effectively
zero cost.
Since Marpa's built-in production ranking
requires only
directly accessible information,
its runtime cost is probably
not measureable.

Certain apps
may require a more powerful and general way of ranking
parse choices,
and might be willing to incur extra costs
to achieve it.
For these apps,
Marpa's ASF's allow full generality in ranking.

=head1 Examples

Our examples in this document will look at minor variations
of the ranked grammar in the synopsis.

=head2 Longest highest, version 1

The first variation we will consider in the one in the
synopsis:

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item3 rank => 6
  List ::= Item2 rank => 5
  List ::= Item1 rank => 4
  List ::= List Item3 rank => 3
  List ::= List Item2 rank => 2
  List ::= List Item1 rank => 1
  Item3 ::= VAR '=' VAR rank => 3 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head3 Longest highest ranking

This one ranks its "items"
(here represented by the sets of symbols,
C<< <Item3> >>,
C<< <Item2> >> and
C<< <Item1> >>)
"longest highest".
Here the "longest" choice is considered to be the one
with the most tokens.
Working this idea out for this grammar,
we get the following,
we see that the items,
from highest to lowest,
should rank in the order given above.

=head3 The non-trivial choicepoints

Several examples and their results are shown
in the synopsis.
If you study the grammar, you will see that
the non-trivial choicepoints
will be for the dotted productions:

=for Marpa::R3::Display
ignore: 1

    List ::= List . Item3
    List ::= List . Item2
    List ::= List . Item1

=for Marpa::R3::Display::End

The above are all of the potential
dotted productions for B<result> choicepoints.

=head3 The cause choicepoints

In all of these dotted productions,
the predot symbol is C<< <List> >>.
Recall that cause choicepoints are always completions.
Since the predot symbol
of all the non-trivial choicepoints is
is C<< <List> >>,
the dotted production of a cause
of the non-trivial choicepoints
may be any of

=for Marpa::R3::Display
ignore: 1

    List ::= Item1 .
    List ::= Item2 .
    List ::= Item3 .
    List ::= List Item1 .
    List ::= List Item2 .
    List ::= List Item3 .

=for Marpa::R3::Display::End

In fact, if we study the grammar more closely,
we will see that the only possible ambiguity is between
items and takes the form "C<(a=)(b)>" versus
"C<(a=b)>", so that the only non-trivial choices are among

=for Marpa::R3::Display
ignore: 1

    List ::= Item3 .
    List ::= Item1 .
    List ::= List Item3 .
    List ::= List Item1 .

=for Marpa::R3::Display::End

=head3 The first non-trivial choicepoints

Further study of the grammar shows that the first non-trivial
choice is between these two:

=for Marpa::R3::Display
ignore: 1

    List ::= Item3 .
    List ::= Item1 .

=for Marpa::R3::Display::End

The production
C<List ::= Item3>
has rank 3,
and it obviously outranks
the production
C<List ::= Item1>,
which has rank 1.
Our example uses C<high_rule_only>
ranking,
and our example therefore will
leave only this choice:

=for Marpa::R3::Display
ignore: 1

    List ::= Item3 .

=for Marpa::R3::Display::End

With only one choice left, the resulting choicepoint
becomes trivial,
and, as defined above, that remaining choice is "longest",
and therefore the correct one for the "longest highest"
ranking.

=head3 The second and subsequent non-trivial choicepoints

We've looked at only the first non-trivial choice
for our example code.
Again examining the grammar, we see that
the second and subsequent non-trivial choices will
all be between causes with the same two dotted
productions:

=for Marpa::R3::Display
ignore: 1

    List ::= List Item3 .
    List ::= List Item1 .

=for Marpa::R3::Display::End

The reasoning for this second and subsequent
non-trivial choice follows the same line as
the reasoning we just gave for the
first non-trivial choice:
The production
C<List ::= List Item3>
has rank 3,
and it obviously outranks
the production
C<List ::= List Item1>,
which has rank 1.
Our example uses C<high_rule_only>
ranking,
and our example therefore will
leave only this choice:

=for Marpa::R3::Display
ignore: 1

    List ::= List Item3 .

=for Marpa::R3::Display::End

=head3 Conclusion

We have now shown that our example will reduce
all choicepoints to a single choice,
one which is consistent with
"longest highest" ranking.
Since all choicepoints are reduced to a single
choice,
the ranked grammar in unambiguous.

Below, there is
a L</"Proof of correctness">.
This could be read as a 2nd, more rigorous,
version of the explanation in this section,
but it requires some patience for math.

=head2 Shortest highest, version 1

Here we see the grammar of the synopsis,
reworked for a "shortest highest"
ranking.
"Shortest highest" is the reverse of
"longest highest.

=for Marpa::R3::Display
name: Ranking, shortest highest, version 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item3 rank => 1
  List ::= Item2 rank => 2
  List ::= Item1 rank => 3
  List ::= List Item3 rank => 4
  List ::= List Item2 rank => 5
  List ::= List Item1 rank => 6
  Item3 ::= VAR '=' VAR rank => 1 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

Here are what the results will look like for
"shortest highest".

=for Marpa::R3::Display
name: Ranking results, shortest highest, version 1

    my @tests = (
        [ 'a = b', '(a=)(b)', ],
        [ 'a = b c = d', '(a=)(b)(c=)(d)' ],
        [ 'a = b c = d e', '(a=)(b)(c=)(d)(e)' ],
        [ 'a = b c = d e =', '(a=)(b)(c=)(d)(e=)' ],
        [ 'a = b c = d e = f', '(a=)(b)(c=)(d)(e=)(f)' ]
    );

=for Marpa::R3::Display::End

The reader who wants an first example of ranking scheme
to work out for themselves may find this one suitable.
The reasoning will be exactly the same as for the
L<"longest highest"
example,|"Longest highest, version 1">
just above .

=head2 Longest highest, version 2

The previous examples have shown the rule involved
in parse ranking in "spelled out" form.
In fact, a more compact form of the grammar can be used,
as shown below for
"longest highest" ranking.

=for Marpa::R3::Display
name: Ranking, longest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item rank => 1
  List ::= List Item rank => 0
  Item ::= VAR '=' VAR rank => 3 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head2 Shortest highest, version 2

This is the grammar for "shortest highest",
in compact form:

=for Marpa::R3::Display
name: Ranking, shortest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item rank => 0
  List ::= List Item rank => 1
  Item ::= VAR '=' VAR rank => 1 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

Again, the reader looking for simple examples to work
out for themselves may want to convince himself
that an argument similar to the one given
L<above for the "spelled out"
examples|Longest highest ranking>
can be worked out for the compact examples.

=head1 Alternatives to Ranking

=head2 Reimplementation as BNF

It is generally better, when possible,
to write a language as BNF, instead of using ranking.
The advantage of using BNF is that you can easily determined
exactly what language it is that you are parsing.
Here is the "longest highest" example,
reimplemented as BNF:

=for Marpa::R3::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= Body Trailer action => main::group
  Body ::= Item3*
  Trailer ::= Item0 | Item1 | Item2
  Item3 ::= VAR '=' VAR action => main::concat
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  Item0 ::= action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

We can also reimplement the "shortest highest"
example as BNF.
One of the advantages of a BNF (re)implementation,
is that it often clarifies the grammar.
For example
in this case, we note that
the DSL rule

=for Marpa::R3::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1
partial: 1

  Item3 ::= VAR '=' VAR action => main::concat

=for Marpa::R3::Display::End

is, in fact, never used.
We therefore omit it:

=for Marpa::R3::Display
name: Ranking via BNF, shortest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= Body Trailer action => main::group
  Body ::= Pair*
  Pair ::= Item2 Item1
  Trailer ::= Item0 | Item1 | Item2
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  Item0 ::= action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head2 Abstract Syntax Forests (ASFs)

Ranking can also be implemented using Marpa's
L<abstract syntax forests|Marpa::R3::ASF>.
ASFs are likely to be less efficient than the built in ranking,
but they are a more general and powerful solution.

=head1 Comparison with PEG

For those familiar with PEG,
Marpa's ranking may seem comparable.
In fact, Marpa's ranking can be seen as a "better PEG".

A PEG specification looks like a BNF grammar,
and it is a common misconception that the language PEG implements
is the same as the language implied by its grammar, when interpreted
as BNF.  This is the case only when the grammar is LL(1) --
in other words, rarely in practical use.

In this section, I will call a PEG specification,
when interpreted as BNF,
the specification's "BNF grammar".
Typically, a PEG implementer thinks their problem out in BNF,
perhaps ordering the PEG rules to resolve a few of the choices,
and then twiddles the PEG specification until the test suite passes.
This results in a parser whose behavior is to a large extent unknown.

Put more directly, the typical PEG implementer does not know what
language they implemented.
PEG implementations often do not parse strings allowed
by the BNF grammar.

Marpa with ranking allows a safer form of PEG-style parsing.
Both Marpa's DSL and PEG allow the implementer to specify
any context-free grammar,
but Marpa will actually parse all of them correctly,
while PEG only correctly parses a small subset and
fakes the rest.

This means that in Marpa,
the implementer of a ranked grammar can work systematically.
He can first write a "superset grammar",
and then "sculpt" it using ranks until he has exactly
the language he wants.
At all points, the superset grammar
will act as a "safety net".
That is,
ranking or no ranking,
Marpa returns no parse trees that are not specified by
the BNF grammar.

This "sculpted superset" is more likely to result in a
satisfactory solution than the PEG approach.
The PEG specification, as BNF, will usually only parse
a subset of what the implementer needs,
and the implementer must use ranks to "stretch" the
grammar to describe what he has in mind.

Ranking is always the more difficult and less predictable,
than specifying BNF.
The "safety net" provided by Marpa's "sculpted superset"
guards against overliberal parsing.
This is important:
overliberal parsing can be a security loophole,
and bugs caused by overliberal parsing have been
the topic of security advisories.

Determining what grammar your ranking actually produces
in PEG is extremely hard --
a small specialist literature has looked at this subject,
but most implementers don't bother --
when the test suite passes, they consider the PEG
implementation complete.

Ranking's effect is more straightforward in Marpa.
Above, we showed very informally that the example
in our synopsis does what it claims to do --
that the parses returned
are actually, and only, those desired.
L<A more formal
proof|"Proof of correctness">
is given below.

Additionally, since Marpa parses all context-free
grammars,
it often parses your language efficiently when it is implemented as pure BNF,
without rule ranking.
For example, this can be done the ranked grammar in the synopsis
can be L<reimplemented as pure unranked
BNF|/"Reimplementation as BNF">.
Where it is possible to convert your ranked grammar to a pure BNF grammar,
that will usually be the best and safest choice.

=head1 Details

This section contains additional explanations, not essential to understanding
the rest of this document.
Often they are formal or mathematical.
While some people find these helpful, others find them distracting,
which is why
they are segregated here.

=head2 Proof of correctness

Let C<G> be the grammar in the
Marpa DSL
synopsis,
treated as it was pure BNF,
without ranking taken into consideration.
Let C<W> be a string,
and let C<P-BNF> be the set of parses
allowed by C<G>.
Let C<P-ranked> be the
set of parses
allowed by C<G> after ranking is taken
into account.

We will say string C<W> is valid
if C<P-BNF> is non-empty.
We will say that C<P-ranked> is
"unambiguous" if and only if
it contains at most one parse.

In the
L<less formal discussion
above|"Longest highest, version 1">,
we used some unstated assumptions
about "longest highest" parses
based on intuition.
Here we make them explicit
and justify them.

We define the "length" of a parse C<p>,
C<Len(p)>,
to be
the number of leaf nodes in it.
We define the "length" of a parse set,
C<Len(ps)>,
to be the maximum "length"
of any parse in C<p-set>.
If C<Len(p-hi) = Len(ps)>,
where C<p-hi> is a parse in
C<ps>,
then C<p-hi> is a
"longest highest" parse.

In C<G>, the leaf nodes take the forms:

=for Marpa::R3::Display
ignore: 1

    VAR
    VAR =
    VAR = VAR

=for Marpa::R3::Display::End

Theorem:
If C<W> is a valid string,
C<P-ranked> contains only one
parse,
and that parse is 
the the "longest highest" parse.

Proof:

The following proof assumes that the reader is comfortable
with analyzing BNF,
and that he is familiar with Earley's algorithm.

=over 4

B<1>: Analyzing the grammar C<G>,
we note the the only potential ambiguities
are in choosing between the pairs of the form "C<(a=)(b)>"
and nodes of the form "C<a=b>".
Note that this implies that completions of C<Item2> and C<Item3>
cannot occur at the same G1 location.
We will refer to this fact later.

B<2>: Wherever ambiguities of the kind
in (1) occur,
they must occur in parse choices
which have one of these 3 symbols as their predot symbol:> =for Marpa::R3::Display

=for Marpa::R3::Display
ignore: 1

    Item1
    Item2
    Item3

=for Marpa::R3::Display::End

B<3>: From (2), and by examination of C<G>, we conclude that all ambiguities
must occur as causes of parse choices
at choicepoints whose dotted rule has the symbol C<< <List> >>
on its LHS.

B<4>: From (1), we note that, when there is an ambiguity,
the choice will always be between the rule

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

      Item3 ::= VAR '=' VAR rank => 3

=for Marpa::R3::Display::End

and the rule

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

      Item1 ::= VAR rank => 1

=for Marpa::R3::Display::End

(The rule for C<Item2> never is one of the choices because,
as implied in (1),
C<Item2> will never be the predot symbol at a location
where C<Item3> is a predot symbol,
and therefore C<Item2> and C<Item3> will never be predot
symbols of choices in the same choicepoint.)

B<5:> Using (4),
and noting rank 3 is higher than rank 1,
we conclude that only one choice will be picked,
and that it will resolve the ambiguity in favor
of "C<(a=b)>", which contains only one leaf.
The other choice would imply the parse contains the pair "C<(a=)(b)>",
which contains two leaves.

B<6:> Generalizing from (5), we observe that all choices are resolved
so that only one choice remains,
and that that choice is "longest highest".

B<7:> From (6) we can show, by induction on the choices in a parse,
that C<P-ranked> will only contain one parse,
and that that parse will be "longest highest".

=back

QED.

=head2 The Rank Induction Theorem

The L<less formal
justification|"Longest highest, version 1">
of the grammar
in the synopsis
relied on an unstated assumption:
that if we optimized the metric used in ranking
at each choicepoint,
this would optimize it over the entire parse set.
This happens to be true for the synopsis grammar,
but it is not true in general.

We define C<Metric> to be a duple of
a tomonoid and a constant:
C<< (M, +, >=), tokval >>.
In the tomonoid
C<< (M, +, >=) >>,
M is a set of metrics,
C<+> is the monoid operation,
and C<< <= >>
is a total ordering over M.
C<tokval> is an element of C<M>.

A "tomonoid" is also called
a totally ordered monoid.
The best known example of a tomonoid
is C<< (N0, +, >=) >>
where C<N0> is the set of natural numbers plus
zero,
C<+> is the operation of addition,
and C<< <= >> is
"less than or equal" as ordinarily
defined.

C<Met> is a monadic function whose value
is an element of the set C<M>,
and therefore a metric.
We overload the function C<Met>,
so that C<x> in C<Met(x)> may be
a token symbol,
a parse choice,
a choicepoint, or
a parse set.
We define C<Met> as follows:

B<Met-parse-set>:
The metric of a parse set C<ps>,
C<Met(ps)>,
is the metric of its top choicepoint.

B<Met-choicepoint>:
The metric of a choicepoint C<cp>,
C<Met(cp)>,
is the maximum
over the metrics of the parse choices
that are the elements of that choicepoint.

B<Met-parse-choice>:
The metric of a parse choice
C<pc = (pred, cause)>,
is C<Met(pc) = Met(pred) + Met(cause)>.
Here C<+> is the tomonoid operation,
which is not necessarily ordinary addition;
C<pred> is the predessor of C<pc>;
and C<cause> is the cause of C<pc>,
which may either be a choicepoint or a symbol.

B<Met-token>:
The metric of a token symbol C<tok>
is the C<tokval> constant:
C<Met(tok) = tokval>.

We say that C<R(pc)> is the "rank" of the parse choice,
where rank is an integer.
We assume that

B<(1)>:
In any non-trivial choicepoint
where C<pc1> and C<pc2> are two parse choices,
if C<< Met(pc1) <= Met(pc2) >>, then
C<< R(pc1) <= R(pc2) >>.

We say that a choicepoint is "reduced"
when all but its highest ranked parse choices
are removed from it.
We say that a choicepoint is "unreduced"
when it contains two choicepoints with different
ranks.

We take as our induction hypothesis that
reduction preserves the metric of the parse
set.
More formally:

B<(HYP)>:
Let C<ps1> be a parse set.
Let C<cp> be an unreduced choicepoint in C<ps1>.
Let C<ps2> be C<ps1> after C<cp>
is reduced.
Then, C<Met(ps2) = Met(ps1)>.

B<Rank Induction Theorem>:
Let C<P-ranked> be the parse set
of a ranked grammar,
and let
C<reduced> be that parse set after
all of its choicepoints have been reduced.
Then, C<Met(reduced) = Met(P-ranked)>.

=head3 Proof

The proof is by induction,
with C<(HYP)> as the induction hypothesis.
As the basis of the induction,
we take
C<Met(P-ranked) = Met(P-ranked)>.
We have the basis of the induction directly.

To show the step of the induction,
we assume that a C<ps1>
is a parse set,
and that it contains an unreduced choicepoint,
C<cp>.
Using ranking, 
we eliminate all but the highest ranked
parse choice,
and call the new parse set C<ps2>.

By C<(1)>, the parse choices with the
highest metrics remain in C<cp> in C<ps2>.
By C<Met-choicepoint>, the metric of the
choicepoint is already the highest metric
of any of its parse elements,
so that the metric of C<cp> in C<ps2>
remains unchanged.
Of the parse choices which remain in C<ps2>,
all get their metric from the tomonoid
operation on token symbols and choicepoints.

Marpa grammars have no cycles, so we can perform
an induction by depth,
starting from the nodes,
which must be leaves,
and proceeding to the
parse set's top choicepoint,
which must have depth 0.
By C<Met-token>
the metrics of the token symbols are constant,
so they will not have changed.
Above, we showed the metric of C<cp> did not
change.
The metrics of the choicepoints other than C<cp>
depend on choicepoints and token symbols of greater depth,
which, as the induction can show, have not changed.

When the induction reaches depth 1,
we are at the
top choicepoint of C<ps2>,
whose metric the induction shows has not changed.
Therefore the metric of the parse set
has not changed,
that is,
C<Met(ps2) = Met(ps1)>.
This shows the step of the induction.

Finally,
since we made no assumptions about the cardinality of C<M>,
the tomonoid's set,
we make a point of showing that the induction terminates.
We note that C<P-ranked> parse set contains a finite
number of choicepoints.
Therefore C<P-ranked> contains a finite number of unreduced choicepoints.
Each induction step reduces one previously unreduced choicepoint.
Therefore the induction terminates after a finite number of steps.

QED.

=head1 COPYRIGHT AND LICENSE

=for Marpa::R3::Display
ignore: 1

  Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.

  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.10.1. For more details, see the full text
  of the licenses in the directory LICENSES.

  This program is distributed in the hope that it will be
  useful, but without any warranty; without even the implied
  warranty of merchantability or fitness for a particular purpose.

=for Marpa::R3::Display::End

=cut

# vim: expandtab shiftwidth=4:
