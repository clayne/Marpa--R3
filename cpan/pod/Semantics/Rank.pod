# Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.
#
# This module is free software; you can redistribute it and/or modify it
# under the same terms as Perl 5.10.1. For more details, see the full text
# of the licenses in the directory LICENSES.
#
# This program is distributed in the hope that it will be
# useful, but it is provided "as is" and without any express
# or implied warranties. For details, see the full text of
# of the licenses in the directory LICENSES.

=head1 NAME

Marpa::R3::Semantics::Rank - How ranks are computed

=head1 Synopsis

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1

    my $source = <<'END_OF_SOURCE';
      :discard ~ ws; ws ~ [\s]+
      :default ::= action => ::array
      
      Top ::= List action => main::group
      List ::= Item3 rank => 6
      List ::= Item2 rank => 5
      List ::= Item1 rank => 4
      List ::= List Item3 rank => 3
      List ::= List Item2 rank => 2
      List ::= List Item1 rank => 1
      Item3 ::= VAR '=' VAR rank => 3 action => main::concat
      Item2 ::= VAR '='     rank => 2 action => main::concat
      Item1 ::= VAR         rank => 1 action => main::concat
      VAR ~ [\w]+

    END_OF_SOURCE

    my @tests = (
        [ 'a = b',             '(a=b)', ],
        [ 'a = b c = d',       '(a=b)(c=d)' ],
        [ 'a = b c = d e',     '(a=b)(c=d)(e)' ],
        [ 'a = b c = d e =',   '(a=b)(c=d)(e=)' ],
        [ 'a = b c = d e = f', '(a=b)(c=d)(e=f)' ],
    );

    my $grammar = Marpa::R3::Grammar->new(
        { ranking_method => 'high_rule_only', source => \$source } );
    for my $test (@tests) {
        my ( $input, $output ) = @{$test};
        my $recce = Marpa::R3::Recognizer->new( { grammar => $grammar } );
        $recce->read( \$input );
        my $value_ref = $recce->value();
        if ( not defined $value_ref ) {
            die 'No parse';
        }
        push @results, ${$value_ref};
    }

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: rank example semantics
normalize-whitespace: 1

    sub flatten {
        my ($array) = @_;

        # say STDERR 'flatten arg: ', Data::Dumper::Dumper($array);
        my $ref = ref $array;
        return [$array] if $ref ne 'ARRAY';
        my @flat = ();
      ELEMENT: for my $element ( @{$array} ) {
            my $ref = ref $element;
            if ( $ref ne 'ARRAY' ) {
                push @flat, $element;
                next ELEMENT;
            }
            my $flat_piece = flatten($element);
            push @flat, @{$flat_piece};
        }
        return \@flat;
    }

    sub concat {
        my ( $pp, @args ) = @_;

        # say STDERR 'concat: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', @{$flat};
    }

    sub group {
        my ( $pp, @args ) = @_;

        # say STDERR 'comma_sep args: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', map { +'(' . $_ . ')'; } @{$flat};
    }

=for Marpa::R3::Display::End

=head1 Description

[ TODO:
A reference to this document,
and consistency with it,
needs to be added into
Marpa::R3::Semantics::Order.
]

=head1 Dotted Productions

To understand this document,
it is helpful to understand what a dotted production is.
Dotted productions are also important in understanding
Marpa's progress reports,
and are thoroughly described
L<in their
documentation|Marpa::R3::Progress>.
This section repeats the main ideas
from the perspective of this document.

Recall that a production is a B<LHS> and a B<RHS>.
The B<LHS> is always exactly one symbol.
The B<RHS> is zero or more symbols.
Consider the following example of a production,
given in the syntax of Marpa's DSL.

=for Marpa::R3::Display
ignore: 1

    S ::= A B C

=for Marpa::R3::Display

Dotted productions are used to track the
progress of a parse through a production.
They consist of a production and a B<dot location>,
which marks the point in the RHS which scanning
has reached.
It is called the B<dot location> because,
traditionally,
the location is represented by a dot.
The symbol before the dot is called
the B<predot symbol>.

The following is an example of a dotted production
in the traditional notation.

=for Marpa::R3::Display
ignore: 1

    S ::= A B . C

=for Marpa::R3::Display

In this production, B<B> is the B<predot symbol>.
(Note that the dot is not allowed in the Marpa DSL,
though it can be seen in some of Marpa's diagnostics.)

When the dot is after the last symbol of the RHS,
the dotted production is called a B<completion>.
Here is the completion for the above production:

=for Marpa::R3::Display
ignore: 1

    S ::= A B C .

=for Marpa::R3::Display

In this completion example, the symbol B<C>
is the predot symbol.

When the dot is before the first symbol of the RHS,
the production is called a B<prediction>.
Here is the prediction of the production we've been
using for our examples:

=for Marpa::R3::Display
ignore: 1

    S ::= . A B C

=for Marpa::R3::Display

In predictions, there is no predot symbol.

=head1 Choicepoints

Informally
a B<choicepoint> is a place where the parser
can decide among B<parse choices>.
For a choicepoint to work, all the choices must
have enough in common that each of them
could be replaced with any other.

A choicepoint can be thought of either the set
of parse choice,
or as a tuple of the properties which all
the parse choices must have in common.

Thought of as the properties, all of the its
parse choices share in common,
a choicepoint is a triple: C<(dp, origin, current)>.
In this triple,

=over 4

=item *

C<dp> is a dotted production.
In a choicepoint, C<dp> is never a prediction,
and therefore there is always a predot symbol.
The predot symbol of C<dp>
is the B<predot symbol> of the choicepoint;
the production of C<dp>
is the B<production> of the choicepoint;
and the
dot position of C<dp>
is the B<dot position> of the choicepoint.

=item *

C<origin> is the G1 location where the dotted
production begins.
C<origin> is sometimes called the B<origin> of the
choicepoint.

=item *

C<dot> is the G1 location corresponding to the dot
in C<dp>.
C<current> is sometimes 
call the C<current position> of the choicepoint.

=back

The choicepoint is a token choicepoint if the
predot symbol of C<dp> is a token symbol.
The choicepoint is a production choicepoint if the
predot symbol of C<dp> is the LHS of a production.
(Token symbols are never the LHS of a production,
and vice versa.)

=head1 Parse choices

As mentioned, a choicepoint can be seen as a set
of one or more B<parse choices>.
Often, there is only one parse choice.
When there is only one parse choice,
the choicepoint is said to be B<trivial>.
Is all of the choicepoints of a parse
are trivial,
the parse is unambiguous.

A parse choice is a duple: C<(predecessor, cause)>.
The first element of the duple is the B<predecessor>
of the parse choice.
The second element of the duple is the B<cause>
of the parse choice.

Every parse choice has a distinct cause.
In every parse choice of a token choicepoint, C<cause> is a token symbol.
A token choicepoint is always trivial --
this is, it always has exactly one parse choice.

A production choicepoint may have many parse choices.
In every parse choice of a production choicepoint,
C<cause> is another choicepoint,
called the B<cause choicepoint>.

If C<cp-prod> is production choicepoint
and C<cp-cuz> is the cause of one of the parse choices,
then we say that C<cp-prod> is the B<result>
of C<cp-cuz>;
and we say that C<cp-cuz> is one of the B<causes>
of C<cp-prod>.

The predecessor of a parse choice represents the portion
of the parse that "leads up to" the cause.
Predecessors are choicepoints but,
since
the predecessor
element of a parse choice plays no role in ranking
decisions,
this document will mostly ignore predecessors.

=head1 Causes

Since it is a choicepoint, a cause choicepoint
must also be a triple.
Let the triple for for C<cp-cuz> be C<(cuz-dp, cuz-origin, current)>.
Let the result of C<cp-cuz> be
C<cp-prod> and
let the
triple for for C<cp-prod> be C<(prod-dp, prod-origin, current)>.

If C<cp-prod> is the result of C<cp-cuz>, then

=over 4

=item *

The dot location of C<cp-cuz>
is the same as the dot location of C<cp-prod>.

=item *

The origin of C<cp-cuz>, C<cuz-origin>,
is before the dot location of C<cp-prod>,


=item *

The origin of C<cp-cuz>, C<cuz-origin>
is at or after the origin of C<cp-prod>.
C<cuz-origin> is sometimes called the
B<middle position> of the choice,
since it is, in a sense,
between the positions
of C<cp-prod>.

=item *

The dotted production of C<cp-cuz> will be a completion.

=item *

The LHS of the dotted production of C<cp-cuz> will be
the predot symbol of C<cp-prod>.

=back

Summing up the above,
the causes of a production choicepoint
vary only by
middle position,
and by their production RHS.
The causes of a production choicepoint
share the same current G1 location
and their dotted productions
are all completion which share
the same LHS.

=head1 Rule Rank

The rank of a parse choice is that of its cause.
If the cause is a token,
the rank of the choice is the rank of the token symbol.
If the cause is a choicepoint,
the rank of the parse choice
is the rank of the production of the cause.

=head1 Motivation

Let C<result> be a production choicepoint.
For the purposes of this section,
the "result-production" is the production of C<result>;
and the "cause-productions" are the productions
of the causes of C<result>.
By the definition of the previous section,
the result-production plays no role in ranking
the parse choices of C<result>.
Instead,
the parse choices of C<result> are ranked by
the cause-productions.

This makes sense, because all parse choices
in the C<result> choicepoint
share the same result-production,
so that the result-production cannot be
a useful part of a ranking method.
On the other hand,
parse choices often
differ in their cause-productions,
and cause-productions are very helpful in
producing a useful ranking method.

Note that ranking is only by direct causes.
That is the cause-productions determine the rank,
but even if there is a tie in the rank of the cause-productions,
the rank of any productions derived from the cause choicepoints
is B<not> considered.

It might be useful to have a scheme that
allows ranking to be inherited.
But such a scheme would be complex,
and would require recursion to implement.
Marpa's built-in production ranking
was chosen to be the most powerful system
that could be implemented with effectively
zero cost.
Since Marpa's built-in production ranking
requires only
directly accessible information,
its runtime cost is probably
not measureable.

Certain apps
may require a more powerful and general way of ranking
parse choices,
and might be willing to incur extra costs
to achieve it.
For these apps,
Marpa's ASF's allow full generality in ranking.

=head1 Examples

Our examples in this document will look at minor variations
of the same toy grammar.

=head2 Longest highest, version 1

The first variation we will consider in the one in the
synopsis:

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item3 rank => 6
  List ::= Item2 rank => 5
  List ::= Item1 rank => 4
  List ::= List Item3 rank => 3
  List ::= List Item2 rank => 2
  List ::= List Item1 rank => 1
  Item3 ::= VAR '=' VAR rank => 3 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head3 Longest highest ranking

This one ranks its "items"
(here represented by the sets of symbols,
C<< <Item1> >>,
C<< <Item2> >> and
C<< <Item3> >>)
"longest highest".
The idea behind "longest highest" is this:

C<< <Item3> >> is of the form "C<a=b>"
and
C<< <Item2> >> is of the form "C<a=>".
"C<a=b>" is obviously longer and therefore
ranks higher,
so that
C<< <Item3> >> ranks higher than
C<< <Item2> >>.
A similarly train of reasoning shows that,
in "longest highest"
C<< <Item2> >> ranks higher than
C<< <Item1> >>.

=head3 The non-trivial choicepoints

Several examples and their results are shown
in the synopsis.
If you study the grammar, you will see that
the non-trivial choicepoints
will be for the dotted productions:

=for Marpa::R3::Display
ignore: 1

    List ::= List . Item1
    List ::= List . Item2
    List ::= List . Item3

=for Marpa::R3::Display::End

The above are all of the potential
dotted productions for B<result> choicepoints.

=head3 The cause choicepoints

In all of these dotted productions,
the predot symbol is C<< <List> >>.
Recall that cause choicepoints are always completions.
Since the predot symbol is C<< <List> >>,
the dotted productions of the causes
of the non-trivial choicepoints
may be any of 

=for Marpa::R3::Display
ignore: 1

    List ::= Item1 .
    List ::= Item2 .
    List ::= Item3 .
    List ::= List Item1 .
    List ::= List Item2 .
    List ::= List Item3 .

=for Marpa::R3::Display::End

In fact, if we study the grammar more closely,
we will see that the only possible ambiguity is between
items and takes the form "C<(a=)(b)>" versus
"C<(a=b)>", so that the only non-trivial choices are among

=for Marpa::R3::Display
ignore: 1

    List ::= Item1 .
    List ::= Item3 .
    List ::= List Item1 .
    List ::= List Item3 .

=for Marpa::R3::Display::End

=head3 The first non-trivial choicepoints

Further study of the grammar shows that the first non-trivial
choice is between these two:

=for Marpa::R3::Display
ignore: 1

    List ::= Item1 .
    List ::= Item3 .

=for Marpa::R3::Display::End

The production
C<List ::= Item3>
has rank 3,
and it obviously outranks
the production
C<List ::= Item1>,
which has rank 1.
Our example uses C<high_rule_only>
ranking,
and our example therefore will
leave only this choice:

=for Marpa::R3::Display
ignore: 1

    List ::= Item3 .

=for Marpa::R3::Display::End

With only one choice left, the resulting choicepoint
becomes trivial,
and clearly that remaining choice is the longest,
and therefore the correct one for the "longest highest"
ranking.

=head3 The second and subsequent non-trivial choicepoints

We've looked at only the first non-trivial choice
for our example code.
Again examining the grammar, we see that
the second and subsequent non-trivial choices will
all be between causes with the same two dotted
productions:

=for Marpa::R3::Display
ignore: 1

    List ::= List Item1 .
    List ::= List Item3 .

=for Marpa::R3::Display::End

The reasoning for this second and subsequent
non-trivial choice follows the same line as
the reasoning we just gave for the
first non-trivial choice:
The production
C<List ::= List Item3>
has rank 3,
and it obviously outranks
the production
C<List ::= List Item1>,
which has rank 1.
Our example uses C<high_rule_only>
ranking,
and our example therefore will
leave only this choice:

=for Marpa::R3::Display
ignore: 1

    List ::= List Item3 .

=for Marpa::R3::Display::End

=head3 Conclusion

We have now shown that our example will render
all choicepoints trivial, and that the remaining
choices will be those consistent with
"longest highest" ranking.

Below, there is
a L</"Proof of correctness">.
This could be read as a 2nd, more rigorous,
version of the explanation in this section,
but it requires some patience with math-i-ness.

=head2 Shortest highest, version 1

Here we see the grammar of the synopsis,
reworked for a "shortest highest"
ranking.
"Shortest highest" is the reverse of
"longest highest.

=for Marpa::R3::Display
name: Ranking, shortest highest, version 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item3 rank => 1
  List ::= Item2 rank => 2
  List ::= Item1 rank => 3
  List ::= List Item3 rank => 4
  List ::= List Item2 rank => 5
  List ::= List Item1 rank => 6
  Item3 ::= VAR '=' VAR rank => 1 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

Here are what the results will look like for
"shortest highest".

=for Marpa::R3::Display
name: Ranking results, shortest highest, version 1

    my @tests = (
        [ 'a = b', '(a=)(b)', ],
        [ 'a = b c = d', '(a=)(b)(c=)(d)' ],
        [ 'a = b c = d e', '(a=)(b)(c=)(d)(e)' ],
        [ 'a = b c = d e =', '(a=)(b)(c=)(d)(e=)' ],
        [ 'a = b c = d e = f', '(a=)(b)(c=)(d)(e=)(f)' ]
    );

=for Marpa::R3::Display::End

The reader who wants an first example of ranking scheme
to work out for themselves may find this one suitable.
The reasoning will be exactly the same as for the
L<"longest highest"
example,|"Shortest highest, version 1">
just above .

=head2 Longest highest, version 2

=for Marpa::R3::Display
name: Ranking, longest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item rank => 1
  List ::= List Item rank => 0
  Item ::= VAR '=' VAR rank => 3 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head2 Shortest highest, version 2

=for Marpa::R3::Display
name: Ranking, shortest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item rank => 0
  List ::= List Item rank => 1
  Item ::= VAR '=' VAR rank => 1 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head1 Alternatives to Ranking

=head2 Reimplementation as BNF

It is generally better, when possible,
to write a language as BNF, instead of using ranking.
The advantage of using BNF is that you can easily determined
exactly what language it is that you are parsing.
Here is the "longest highest" example,
reimplemented as BNF:

=for Marpa::R3::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= Body Trailer action => main::group
  Body ::= Item3*
  Trailer ::= Item0 | Item1 | Item2
  Item3 ::= VAR '=' VAR action => main::concat
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  Item0 ::= action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

We can also reimplement the "shortest highest"
example as BNF.
In this case note that, in the course of converting
to BNF, we discover that the rule

=for Marpa::R3::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1
partial: 1

  Item3 ::= VAR '=' VAR action => main::concat

=for Marpa::R3::Display::End

is, in fact, never used.
We therefore omit it:

=for Marpa::R3::Display
name: Ranking via BNF, shortest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= Body Trailer action => main::group
  Body ::= Pair*
  Pair ::= Item2 Item1
  Trailer ::= Item0 | Item1 | Item2
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  Item0 ::= action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head2 Abstract Syntax Forests (ASFs)

=head1 Comparison with PEG

=head1 Caveats

[ TODO: Are these all covered elsewhere?
Do I need this section? ]

=head1 Details

This section contains additional explanations, not essential to understanding
the rest of this document.
Often they are formal or mathematical.
While some people find these helpful, others find them distracting,
which is why
they are segregated here.

=head2 Proof of correctness

Let C<G> be the grammar in the
Marpa DSL
synopsis,
treated as it was pure BNF,
without ranking taken into consideration.
Let C<W> be a string,
and let C<P-BNF> be the set of parses
allowed by C<G>.
Let C<P-ranked> be the
set of parses
allowed by C<G> after ranking is taken
into account.

We will say string C<W> is valid
is C<P-BNF> is non-empty.
We will say that C<P-ranked> is
"unambiguous" if and only if
it contains at most one parse.

It is necessary to clarify what we mean
by the "longest highest" parse.
In C<G>, the leaf nodes take the forms:

=for Marpa::R3::Display
ignore: 1

    VAR
    VAR =
    VAR = VAR

=for Marpa::R3::Display::End

The "longest highest" parse is the one which
contains the fewest leaf nodes.

Theorem:
If C<W> is a valid string,
C<P-ranked> contains only one
parse,
and that parse is 
the the "longest highest" parse.

Proof:

The following proof assumes that the reader is comfortable
with analyzing BNF,
and that he is familiar with Earley's algorithm.

=over 4

=item 1:

Analyzing the grammar C<G>,
we note the the only potential ambiguities
are in choosing between the pairs of the form "C<(a=)(b)>"
and nodes of the form "C<a=b>".
Note that this implies that completions of C<Item2> and C<Item3>
cannot occur at the same G1 location.
We will refer to this fact later.

=item 2:

Second, we note that, wherever ambiguities of the kind
just mentioned occur,
they must occur in choices
which have one of these 3 symbols as their predot symbol:

=for Marpa::R3::Display
ignore: 1

    Item1
    Item2
    Item3

=for Marpa::R3::Display::End

=item 3:

From (2), and by examination of C<G>, we conclude that all ambiguities
must occur as causes of choices
at choicepoints whose dotted rule has the symbol C<< <List> >>
on its LHS.

=item 4:

From (1), we note that, when there is an ambiguity,
the choice will always be between the rule

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

      Item3 ::= VAR '=' VAR rank => 3

=for Marpa::R3::Display::End

and the rule

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

      Item1 ::= VAR rank => 1

=for Marpa::R3::Display::End

(The rule for C<Item2> never is one of the choices because,
as implied in (1),
C<Item2> will never be the predot symbol at a location
where C<Item3> is a predot symbol,
and therefore C<Item2> and C<Item3> will never be predot
symbols of choices in the same choicepoint.)

=item 5:

Using (4),
and noting rank 3 is higher than rank 1,
we conclude that only one choice will be picked,
and that it will resolve the ambiguity in favor
of "C<(a=b)>", which contains only one leaf.
The other choice would imply the parse contains the pair "C<(a=)(b)>",
which contains two leaves.

=item 6:

Generalizing from (5), we observe that all choices are resolved
so that only one choice remains,
and that that choice is "longest highest".

=item 7:

From (6) we can show, by induction on the choices in a parse,
that C<P-ranked> will only contain one parse,
and that that parse will be "longest highest".

=back

QED.

=head1 COPYRIGHT AND LICENSE

=for Marpa::R3::Display
ignore: 1

  Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.

  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.10.1. For more details, see the full text
  of the licenses in the directory LICENSES.

  This program is distributed in the hope that it will be
  useful, but without any warranty; without even the implied
  warranty of merchantability or fitness for a particular purpose.

=for Marpa::R3::Display::End

=cut

# vim: expandtab shiftwidth=4:
