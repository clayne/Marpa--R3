# Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.
#
# This module is free software; you can redistribute it and/or modify it
# under the same terms as Perl 5.10.1. For more details, see the full text
# of the licenses in the directory LICENSES.
#
# This program is distributed in the hope that it will be
# useful, but it is provided "as is" and without any express
# or implied warranties. For details, see the full text of
# of the licenses in the directory LICENSES.

=head1 NAME

Marpa::R3::Semantics::Rank - How ranks are computed

=head1 Synopsis

=for Marpa::R3::Display
name: Rank document synopsis
normalize-whitespace: 1

    my $source = <<'END_OF_SOURCE';
      :discard ~ ws; ws ~ [\s]+
      :default ::= action => ::array
      
      Top ::= List action => main::group
      List ::= Item3 rank => 6
      List ::= Item2 rank => 5
      List ::= Item1 rank => 4
      List ::= List Item3 rank => 3
      List ::= List Item2 rank => 2
      List ::= List Item1 rank => 1
      Item3 ::= VAR '=' VAR rank => 3 action => main::concat
      Item2 ::= VAR '='     rank => 2 action => main::concat
      Item1 ::= VAR         rank => 1 action => main::concat
      VAR ~ [\w]+

    END_OF_SOURCE

    my @tests = (
        [ 'a = b',             '(a=b)', ],
        [ 'a = b c = d',       '(a=b)(c=d)' ],
        [ 'a = b c = d e',     '(a=b)(c=d)(e)' ],
        [ 'a = b c = d e =',   '(a=b)(c=d)(e=)' ],
        [ 'a = b c = d e = f', '(a=b)(c=d)(e=f)' ],
    );

    my $grammar = Marpa::R3::Grammar->new(
        { ranking_method => 'high_rule_only', source => \$source } );
    for my $test (@tests) {
        my ( $input, $output ) = @{$test};
        my $recce = Marpa::R3::Recognizer->new( { grammar => $grammar } );
        $recce->read( \$input );
        my $value_ref = $recce->value();
        if ( not defined $value_ref ) {
            die 'No parse';
        }
        push @results, ${$value_ref};
    }

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: rank example semantics
normalize-whitespace: 1

    sub flatten {
        my ($array) = @_;

        # say STDERR 'flatten arg: ', Data::Dumper::Dumper($array);
        my $ref = ref $array;
        return [$array] if $ref ne 'ARRAY';
        my @flat = ();
      ELEMENT: for my $element ( @{$array} ) {
            my $ref = ref $element;
            if ( $ref ne 'ARRAY' ) {
                push @flat, $element;
                next ELEMENT;
            }
            my $flat_piece = flatten($element);
            push @flat, @{$flat_piece};
        }
        return \@flat;
    }

    sub concat {
        my ( $pp, @args ) = @_;

        # say STDERR 'concat: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', @{$flat};
    }

    sub group {
        my ( $pp, @args ) = @_;

        # say STDERR 'comma_sep args: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', map { +'(' . $_ . ')'; } @{$flat};
    }

=for Marpa::R3::Display::End

=head1 Description

[ TODO:
A reference to this document,
and consistency with it,
needs to be added into
Marpa::R3::Semantics::Order.
]

=head1 Dotted Productions

To understand this document,
it is helpful to understand what a dotted rule is.
Dotted rules are also important in understanding
Marpa's progress reports,
and are thoroughly described
L<in their
documentation|Marpa::R3::Progress>.
For convenience,
this section briefly repeats the main ideas
used in this document.

Recall that a production is a B<LHS> and a B<RHS>.
The B<LHS> is always exactly one symbol.
The B<RHS> is zero or more symbols.
Consider the following example of a production,
given in the syntax of Marpa's DSL.

=for Marpa::R3::Display
ignore: 1

    S ::= A B C

=for Marpa::R3::Display

Dotted productions are used to track the
progress of a parse through a production.
They consist of a rule and a B<dot location>,
which marks the point in the RHS which scanning
has reached.
It is called the B<dot location> because,
traditionally,
the location is represented by a dot.
The symbol before the dot is called
the B<predot symbol>.

The following is an example of a dotted rule
in the traditional notation.

=for Marpa::R3::Display
ignore: 1

    S ::= A B . C

=for Marpa::R3::Display

In this rule, B<B> is the B<predot symbol>.
(Note that the dot is not allowed in the Marpa DSL,
though it can be seen in some of Marpa's diagnostics.)

When the dot is after the last symbol of the RHS,
the dotted production is called a B<completion>.
Here is the completion for the above production:

=for Marpa::R3::Display
ignore: 1

    S ::= A B C .

=for Marpa::R3::Display

In this completion example, the symbol B<C>
is the predot symbol.

When the dot is before the first symbol of the RHS,
the production is called a B<prediction>.
Here is the prediction of the production we've been
using for our examples:

=for Marpa::R3::Display
ignore: 1

    S ::= . A B C

=for Marpa::R3::Display

In predictions, there is no predot symbol.

=head1 Choicepoints

A choicepoint is a triple: C<(dp, origin, dot)>.
In this triple,

=over 4

=item *

C<dp> is a dotted production.
In a choicepoint, C<dp> is never a prediction,
and therefore there is always a predot symbol.

=item *

C<origin> is the G1 location where the dotted
rule begins.
C<origin> is sometimes called the B<origin> of the
choicepoint.

=item *

C<dot> is the G1 location corresponding to the dot
in C<dp>.
C<dot> is sometimes 
call the C<dot position> of the choicepoint.

=back

The choicepoint is a token choicepoint if the
predot symbol of C<dp> is a token symbol.
The choicepoint is a rule choicepoint if the
predot symbol of C<dp> is the LHS of a rule.
(Token symbols are never the LHS of a rule,
and vice versa.)

A choicepoint contains one or B<choices>,
each of which has a distinct B<cause>.
A token choicepoint always has exactly one choice.
The cause of a token choicepoint is its token
symbol.

A rule choicepoint may have many choices.
The cause of a rule choicepoint is another choicepoint,
which we may call its cause choicepoint.
If C<result-cp> is a choicepoint,
and C<cause-cp> is the cause choicepoint of
C<result-cp>,
we call C<result-cp> the
B<result> of C<cause-cp>.

Since it is a choicepoint, the cause choicepoint
must also be a triple.
Let the triple for for C<cause-cp> be C<(cause-dp, cause-origin, dot)>.
Let the result of C<cause-cp> be
C<result-cp> and
let the
triple for for C<result-cp> be C<(result-dp, result-origin, dot)>.

If C<result-cp> is the result of C<cause-cp>, then

=over 4

=item *

The dot location of C<cause-cp>
is the same as the dot location of C<result-cp>.

=item *

The origin of C<cause-cp>, C<cause-origin>,
is before the dot location of C<result-cp>,


=item *

The origin of C<cause-cp>, C<cause-origin>
is at or after the origin of C<result-cp>.


=item *

The dotted production of C<cause-cp> will be a completion.

=item *

The LHS of the dotted production of C<cause-cp> will be
the predot symbol of C<result-cp>.

=back

C<cause-origin> is sometimes called the
B<middle position> of the choice,
since it is, in a sense,
between the positions
of C<result-cp>.
Summing up the above, the choices at a rule choicepoint
can vary by origin and dotted production,
but the origins must all fall within a range,
and the dotted productions must all be completions
with the same LHS.

=head1 Rule Rank

The way in which the rank of a choice
is defined
may seem
counter-intuitive at first.
We will first state it directly.
Below we will motivate the definition.

The rank of a choice is that of its cause.
If the cause is a token,
the rank of the choice is the rank of the token symbol.

If the cause is a choicepoint,
the rank of the choice is the rank of the rule of the cause.

=head1 Motivation

Note that,
the rank of a result choicepoint did not come from
the result choicepoint's rule,
but from the rules of the causes of that result choicepoint.
This may seem unnatural,
but we can show that it makes sense.

First, if ranking is by the rule of the choices in a choicepoint,
there would, in fact, be no ranking,
because all the rules would be the same.

Second, since the origin and dot position of all the choices in a
choicepoint are the same,
all comparisons would have to be between rules of the same length.
This would be, in practice, a severe restriction.

In fact, experiment has shown that the most intuitive idea of ranking
must at least allow ranking by causes.

In Marpa, rule ranking is only by causes, and only by direct causes.
This is restrictive but it was chosen because it is still
quite powerful and can be implemented
extremely efficiently.
The runtime cost of Marpa's built-in rule ranking is probably
not measureable.

Certain apps
may require a more powerful and general way of ranking
parse choices,
and be willing to incur an overhead to obtain it.
For these apps,
Marpa's ASF's allow full generality in ranking.

=head1 Examples

=for Marpa::R3::Display
name: Ranking, longest highest, version 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item3 rank => 6
  List ::= Item2 rank => 5
  List ::= Item1 rank => 4
  List ::= List Item3 rank => 3
  List ::= List Item2 rank => 2
  List ::= List Item1 rank => 1
  Item3 ::= VAR '=' VAR rank => 3 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: Ranking, shortest highest, version 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item3 rank => 1
  List ::= Item2 rank => 2
  List ::= Item1 rank => 3
  List ::= List Item3 rank => 4
  List ::= List Item2 rank => 5
  List ::= List Item1 rank => 6
  Item3 ::= VAR '=' VAR rank => 1 action => main::concat
  Item2 ::= VAR '='     rank => 2 action => main::concat
  Item1 ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: Ranking, longest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array
  
  Top ::= List action => main::group
  List ::= Item rank => 1
  List ::= List Item rank => 0
  Item ::= VAR '=' VAR rank => 3 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=for Marpa::R3::Display
name: Ranking, shortest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item rank => 0
  List ::= List Item rank => 1
  Item ::= VAR '=' VAR rank => 1 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R3::Display::End

=head1 Caveats

In the above example, it is tempting to simplify by adding a rule
which saves typing all 3 choices in
two different places:
For example,

=for Marpa::R3::Display
ignore: 1

    <Item> ::= <Item1> | <Item2> | <Item3>

=for Marpa::R3::Display::End

But adding a rule like this breaks ranking, because ranks are not
evaluated recursively, so that adding a layer of indirection (which in
most cases in Marpa has almost no effect) hides the rule rank --
it now becomes the rank not of the predot child, but of the child of
the predot child.

=head1 COPYRIGHT AND LICENSE

=for Marpa::R3::Display
ignore: 1

  Marpa::R3 is Copyright (C) 2017, Jeffrey Kegler.

  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.10.1. For more details, see the full text
  of the licenses in the directory LICENSES.

  This program is distributed in the hope that it will be
  useful, but without any warranty; without even the implied
  warranty of merchantability or fitness for a particular purpose.

=for Marpa::R3::Display::End

=cut

# vim: expandtab shiftwidth=4:
