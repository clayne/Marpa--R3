# Copyright 2018 Jeffrey Kegler
# This file is part of Marpa::R3.  Marpa::R3 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R3 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R3.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R3::External::Low - Low-level external scanning

=head1 About this document

The alternative input models described in this document are an
advanced technique.
If you are starting out with Marpa, you
probably want to ignore this document.
If you are an experienced Marpa user,
it is still safe to ignore this document,
but you might find the possibilities it discusses
interesting.

This is not the document to which to turn first.
Before reading this document, you should be familiar with
L<Marpa::R3::External::Basic>.

=head1 Earlemes, intuitively

In the other Marpa documentation,
we have assumed the standard input model,
and the only idea of
G1 location we have used is Earley set location --
that is, location as an Earley set ordinal.
(An Earley set's ordinal is also its ID.)

For advanced input models, we must introduce another
idea of G1 location -- earleme location.
Earleme location is ignored in the other Marpa documents,
and it can be, because they
assume the standard input model.
Use of the standard input model
guarantees that earleme
and Earley set ordinal
will always be exactly the same.

This document introduces methods which make it
very possible that earleme location and
Earley set ID will differ.
From here on,
the reader will need to pay careful attention
to the distinction.

Intuitively, earlemes exist because
because the usual idea of location,
G1 location, is tied to the tokenization,
For most applications, it is OK to reduce the parser's idea of
location to tokenization.
When an application ties earlemes to the tokenization,
it is using the earleme-per-token model.
This is the default.

Location can also be tied to the physical input.
That is the earleme-per-character model.
But Marpa allows multiple input blocks,
and jumping back and forth in them.
This ability is required in many practical applications.
Some applications, therefore,
cannot use either the
earleme-per-token or
the earleme-per-character model.

Earlemes provide a "middle" ground.
They are zero-based and monotonic,
and therefore can be relied on as a well-behaved idea of location.
But they are otherwise completely flexible,
since they do not have to be tied to physical input, tokenization,
or any other aspect of the parse,

=head1 Earlemes, more formally

There are only three restrictions:

=over 4

=item *

Every Earley set maps to a unique earleme.
This is,
if I<Xes> and I<Yes> are the IDs of two Earley sets,
I<Xearleme> is the earleme of I<Xes>, aqnd
I<Yearleme> is the earleme of I<Yes>,
then I<Xes>C<=>I<Yes> if and only if
I<Xearleme>C<=>I<Yearleme>.

=item *

The earlemes increase monotonically with the 
IDs of the Earley sets.
That is, again
let I<Xes> and I<Yes> be the IDs of two Earley sets;
let I<Xearleme> be earleme of I<Xes> and
let I<Yearleme> be earleme of I<Yes>.
Then I<Xes>C<< < >>I<Yes> if and only if
I<Xearleme>C<< < >>I<Yearleme>.

=item *

Earley set 0 is always earleme 0,
and vice versa.

=item *

The start earleme of a token is the earleme of the Earley
set at which the token starts.

=item *

The end earleme of a token is the earleme of the Earley
set at which the token ends.

=item *

Every token has a length in earlemes.
Call the start earleme of a token, I<start>
and the end earleme of a token, I<end>.
Then the length of the token is I<start>C<->I<end>.

=item *

The length of a token must be 1 or greater.

=back

Less formally, the above states that
all tokens starting at
earleme I<N> must be scanned before
any tokens starting at earleme I<N+1>;
that earleme location, like Earley set ID
is zero-based;
and that tokens are never zero-length.

=head1 What is an alternative input model?

An alternative input model
is anything that is not the default, token-stream model.
More helpfully, Marpa allows variable-length tokens and ambiguous tokens,
and an alternative input model is any input model which

=over

=item *

allows a token whose length is not exactly 1, or

=item *

allows locations which have more than one token.

=back

To do either of these things,
a user must use the recognizer's
L<low level external scanning
methods|Marpa::R3::External::Basic/"Low-level mutators">:
L<C<lexeme_alternative()>|Marpa::R3::External::Basic/"lexeme_alternative()">,
and
L<C<lexeme_alternative_literal()>|Marpa::R3::External::Basic/"lexeme_alternative_literal()">.
If an application is not directly
using one of these two methods,
then that application is not using an alternative input method.

Many concepts, such as parsing location,
parse exhaustion,
and the end of parsing,
become more complicated when alternative
input models are involved.
In L<the main document for the recognizer|Marpa::R3::Recognizer>
these concepts were explained on the assumption
that the default input model was in use.
This document expands revises those explanations as necessary
to take into
account the alternative input models.

=head1 Token streams

Marpa's default input model is the traditional one --
a token stream.
Token streams are very standard in parsing applications --
so much so
that most texts do not take the trouble
of defining the term.
A B<token stream> is input structured as
a sequence of tokens,
where each token occupies one location
and every location has a token.
In the token stream model, all tokens are
of the same length.

Conventionally, all tokens are of length 1,
and the token stream starts at location 0.
Following this convention,
the I<N>th token would start at
location I<N-1> and end
at location I<N>.
For example,
the first token would start at location 0 and end at location 1.
The second token would start at location 1 and end at location 2.

=head1 Earlemes

For most parsers, position is location in a token stream.
To deal with variable-length and overlapping tokens,
Marpa needs a more flexible idea of location.
L<A separate
document|Marpa::R3::External::Model>
gives full and more precise detail on earleme location,
but this document should be read first for an overview.

Marpa's tracks position in terms of B<earlemes>.
B<Earlemes> are named after Jay Earley,
the inventor of the first algorithm
in Marpa's lineage.
Every token has a start earleme and an end earleme.

The token stream model may also be called the token-per-earleme
model.
In the token stream model,
token location and earleme location
are exactly identical.
More formally, in the token stream model,
if the token location is I<N>,
then the earleme location is also I<N>.
If a user's application uses the token stream model,
the user can ignore the existence of earlemes,
and can think entirely in terms of
tokens and their position in a token stream.
Because of this, the main Marpa documents
often speak
simply of the "location" in the parse.

=head1 The furthest earleme

The B<furthest earleme> is the last earleme at which a token ends.
In the default input model,
the furthest earleme and the latest earleme
are always the same.
As a result,
in the default input model, the furthest earleme is not an important
concept.

In alternative input models,
tokens may be longer than 1 earleme, and
the furthest earleme and the latest earleme may be far apart.
To ensure
that processing of input catches up to the furthest earleme,
applications using alternative input models may have to call the
the recognizer's L<C<lexeme_complete>|/"lexeme_complete()"> method repeatedly.

=head1 The latest Earley set and latest earleme

The B<latest earleme> is the earleme location of the latest
Earley set.
In the default input model, the latest earleme is always the
same as the furthest earleme.

=head1 Methods

=head2 closest_earleme()

=for Marpa::R3::Display
name: recognizer closest_earleme() synopsis
normalize-whitespace: 1

    my $closest_earleme = $recce->closest_earleme();

=for Marpa::R3::Display::End

Returns the closest earleme.

=head2 current_earleme()

=for Marpa::R3::Display
name: recognizer current_earleme() synopsis
normalize-whitespace: 1

    my $current_earleme = $recce->current_earleme();

=for Marpa::R3::Display::End

Returns the current earleme.

=head2 earleme()

=for Marpa::R3::Display
name: recognizer earleme() synopsis
normalize-whitespace: 1

  my $latest_earley_set = $recce->g1_pos();
  $latest_earleme = $recce->earleme($latest_earley_set);

=for Marpa::R3::Display::End

Given an Earley set ID as its argument,
the C<earleme()> recognizer method
returns the corresponding earleme.
Every integer in the range from 0
to the ID of the latest Earley
is a valid Earley set ID,
and every valid Earley set ID corresponds to an
earleme.
If the argument of C<earleme()> is
greater than the latest Earley set ID,
C<earleme()> returns Perl C<undef>.

There is currently no method that translates from
earleme to Earley set.
Earley set to earleme translation is a well-behaved
one-to-one function
in all input models -- for every Earley set there is
a earleme,
and every earleme is mapped to by at most one Earley set.
Earleme to Earley set translation is far less well-behaved.
In many input models, it is a partial function -- there
are some earlemes that are
in the valid range of earlemes
but do not map to any Earley set.

As an alternative to the C<earleme()> method,
an application
may want to its own Earley set to earleme mapping.
This can allows an application to take advantage of what
it knows about its choice of input model.

=head2 furthest_earleme()

=for Marpa::R3::Display
name: recognizer furthest_earleme() synopsis
normalize-whitespace: 1

    my $furthest_earleme = $recce->furthest_earleme();

=for Marpa::R3::Display::End

Returns the furthest earleme.

=head2 g1_pos()

=for Marpa::R3::Display
name: recognizer earleme() synopsis
normalize-whitespace: 1
partial: 1

  my $latest_earley_set = $recce->g1_pos();

=for Marpa::R3::Display::End

The C<g1_pos()> method
returns ID of the latest Earley set.
The full description of the C<g1_pos()> method is
L<elsewhere|Marpa::R3::Recognizer/"g1_pos()">.

=head2 latest_earleme()

=for Marpa::R3::Display
name: recognizer latest_earleme() synopsis
normalize-whitespace: 1

    my $latest_earleme = $recce->latest_earleme();

=for Marpa::R3::Display::End

Returns the latest earleme.
Always succeeds.

=head2 lexeme_alternative()

=for Marpa::R3::Display
name: recognizer lexeme_alternative() variable length synopsis
normalize-whitespace: 1

    $ok = $recce->lexeme_alternative( 'A', 42, 2 );

=for Marpa::R3::Display::End

C<lexeme_alternative()> is one of the low level scanning
mutators used for alternate input models.
Its last argument is the earleme length, which allows
variable length lexemes.
For more about C<lexeme_alternative()> consult
L<its full
description|Marpa::R3::Recognizer/"g1_pos()">.

=head2 lexeme_alternative_literal()

=for Marpa::R3::Display
name: recognizer lexeme_alternative_literal() variable length synopsis
normalize-whitespace: 1

    $ok = $recce->lexeme_alternative_literal( 'A', 3 );

=for Marpa::R3::Display::End

C<lexeme_alternative_literal()> is one of the low level scanning
mutators used for alternate input models.
Its last argument is the earleme length, which allows
variable length lexemes.
For more about C<lexeme_alternative_literal()> consult
L<its full
description|Marpa::R3::Recognizer/"g1_pos()">.

=head2 lexeme_complete()

=for Marpa::R3::Display
name: recognizer lexeme_complete() synopsis
partial: 1
normalize-whitespace: 1

    my $new_offset = $recce->lexeme_complete( $block_id, $offset, $length );

=for Marpa::R3::Display::End

C<lexeme_complete()> is the low level mutator used
in alternative input models.
C<lexeme_complete()> moves the parse forward to the
next earleme at which a lexeme ends.

TODO

=head1 Alternative models and high level scanning

A recognizer can alternate
calls to its
L<high level scanning methods
methods|Marpa::R3::External::Basic/"High-level mutators">
with calls to its
L<low level scanning methods
methods|Marpa::R3::External::Basic/"Low-level mutators">,
with one restriction:
If a low level scan at a particular earleme has been
started with
L<C<lexeme_alternative()>|Marpa::R3::External::Basic/"lexeme_alternative()">,
and
L<C<lexeme_alternative_literal()>|Marpa::R3::External::Basic/"lexeme_alternative_literal()">,
it must be completed with a call to
L<C<lexeme_complete()>|Marpa::R3::External::Basic/"lexeme_complete()">
before any high level scanning method can be called.
Otherwise a fatal error results.

=head1 Ambiguous lexing

Marpa allows ambiguous tokens.
Several Marpa tokens can start at a single parsing location.
Ambiguous tokens can be of various lengths.
Tokens can also overlap.

B<Potentially
ambiguous lexing>
occurs when more than one token starts
at a single earleme.
When potentially ambiguous lexing occurs,
it becomes possible for there to be more
than one sequence of tokens.

An B<actual lexical ambiguity> only occurs if
more than one of the potential token sequences is consistent with
the grammar.
If there is no actual lexical ambiguity,
Marpa will use the only token choice that is
consistent with the grammar.

When lexing is B<actually ambiguous>, Marpa
will use all the alternatives
consistent with the grammar.
When the lexing in a parse is actually ambiguous,
the parse will be ambiguous.
From the point of view of Marpa's semantics,
ambiguities caused by lexing look the
same as ambiguities caused by an ambiguous grammar.

In the standard
terminology,
if a grammar produces more than one parse tree
for any input,
then that grammar must be ambiguous.
In Marpa this is not strictly true.
In Marpa,
if the input is ambiguous,
even an unambiguous grammar can produce more than one parse.

=head1 Duplicate tokens

A duplicate token is a token of the same type
and the same length as another
that was read at the same earleme.
Duplicate tokens are impossible in the default, token-stream,
model.
This is because in the token-stream model only one token can be
read at each earleme.

In alternative models, more than one token may be read at
an earleme, and duplicates B<are> possible.
Marpa detects duplicate tokens and treats them as
"hard errors" --
Marpa throws an exception
when it sees a duplicate token.
Marpa's assumption is that
duplicate tokens indicate
an error at the application level.

An application can retry input after
a duplicate token, if it
catches the exception.
In the future, if recovery from duplicate tokens is found
to be a useful technique, Marpa may provide an option to change
its behavior, so that a soft failure is returned
when there is a duplicate token.

=head1 Earlemes: the details

While scanning, Marpa keeps track of the B<current earleme>.
Earlemes in a parse start at earleme 0 and increase numerically.
The earleme immediately following earleme 0 is earleme 1,
the earleme immediately following earleme 1 is earleme 2,
and so on.
The earleme immediately following earleme I<N> is always earleme I<N+1>.

B<Distance> in the earleme stream is
what you would intuitively expect it to be.
The distance between earleme I<X> and earleme I<Y> is
the absolute value of the difference between I<X> and I<Y>,
I<|X-Y|>.
The distance from earleme 3 to earleme 6,
for example, is 3 earlemes.

Whenever a token is given to Marpa to be scanned,
it starts at the current earleme.
In addition to the type and value of the token,
Marpa must be told the token's B<length> in earlemes.
The length of a Marpa token must be greater than zero.

This earleme length will become
the distance from the start of the
token to the end of the token.
If the length of the token is I<L>,
and the current earleme is I<C>,
the end of the token will be at earleme I<C+L>.

=head1 The character-per-earleme model

Many different models of the relationship between tokens and earlemes
are possible, but two are particularly important.
One is the one-token-per-earleme model,
which is the default,
and which has already been described.
The other is the one-character-per-earleme model.

In the one-character-per-earleme model,
every character will be treated as being exactly one
earleme in length.
If a token is more than one character in length,
that token will span earlemes.
When the lexing is ambiguous, tokens may overlap.

When a one-character-per-earleme model of input is used,
there may be many earlemes at which no tokens start.
For example,
in a straightforward character-per-earleme implementation
of a grammar for a language that allows
comments,
no tokens will start at
any earlemes which correspond to character locations inside
a comment.

=head1 Other input models

So far only the token-per-earleme and
character-per-earleme models have seen any
real use in Marpa programs.
But other models are certainly possible.
Using earlemes,
you can structure your input in almost any way you like.

=head1 Mixing internal and external scanning

External scanning can be mixed with internal scanning
to get the best of both.
An application can
terminate the internal scanning of
the C<read()> method early, if it has defined an parse event
and that parse event triggers.
Afterwards,
internal scanning can be resumed with the L<resume()|/"resume()"> method.
For details,
see L<the description of C<resume()>|Marpa::R3::Recognizer/"resume()">,
as well as
L<the separate document for events|Marpa::R3::Event>.

=head1 High level equivalents

=head2 Low level equivalent of C<lexeme_read_block()>

=for Marpa::R3::Display
ignore: 1

    $recce->lexeme_read_block($symbol, $start, $length, $value)

=for Marpa::R3::Display::End

is roughly equivalent to

=for Marpa::R3::Display
name: recognizer lexeme_read_block() low-level equivalent
normalize-whitespace: 1

    sub read_block_equivalent {
        my ( $recce, $symbol_name, $value, $block_id, $offset, $length ) = @_;
        return if not defined $recce->lexeme_alternative( $symbol_name, $value );
        return $recce->lexeme_complete( $block_id, $offset, $length );
    }

=for Marpa::R3::Display::End

=head2 Low level equivalent of C<lexeme_read_literal()>

In terms of low-level external scanning methods,
the above is roughly equivalent to

=for Marpa::R3::Display
name: recognizer lexeme_read_literal() low-level equivalent
normalize-whitespace: 1

    sub read_literal_equivalent_lo {
        my ( $recce, $symbol_name, $block_id, $offset, $length ) = @_;
        return if not defined $recce->lexeme_alternative_literal( $symbol_name );
        return $recce->lexeme_complete( $block_id, $offset, $length );
    }

=for Marpa::R3::Display::End

=head2 Low level equivalent of C<lexeme_read_string()>

In terms of low-level external scanning methods,
C<lexeme_read_string()> is roughly equivalent to

=for Marpa::R3::Display
name: recognizer lexeme_read_string() low-level equivalent
normalize-whitespace: 1

    sub read_string_equivalent_lo {
        my ($recce, $symbol_name, $string) = @_;
        my ($save_block) = $recce->block_progress();
        my $lexeme_block = $recce->block_new( \$string );
        return if not defined $recce->lexeme_alternative( $symbol_name, $string );
        my $return_value = $recce->lexeme_complete( $lexeme_block );
        $recce->block_set($save_block);
        return $return_value;
    }

=for Marpa::R3::Display::End

The example just above shows the value of the token being set to a string
in the C<lexeme_alternative()> call.
Not that this is not efficient for very long strings.

=head1 Low-level mutators

This section documents the low-level external scanning methods.
The low-level mutators allows some advanced techniques,
notably the reading of ambiguous tokens.
Most applications will want to use
L<the high-level methods|High-level mutators>
instead.

=head2 lexeme_alternative()

=for Marpa::R3::Display
name: recognizer lexeme_alternative() synopsis
partial: 1
normalize-whitespace: 1

    my $ok = $recce->lexeme_alternative( $symbol_name, $value );
    if (not defined $ok) {
        my $literal = $recce->literal( $block_id, $offset, $length );
        die qq{Parser rejected symbol named "$symbol_name" },
            qq{at position $offset, before lexeme "$literal"};
    }

=for Marpa::R3::Display::End

For advanced uses,
there is also a three-argument form:

=for Marpa::R3::Display
name: recognizer lexeme_alternative() variable length synopsis
normalize-whitespace: 1

    $ok = $recce->lexeme_alternative( 'A', 42, 2 );

=for Marpa::R3::Display::End

C<lexeme_alternative()> is one of the low-level methods of the external scanner.
Most applications
will prefer the simpler
L<C<lexeme_read_string()>|/"lexeme_read_string()">,
L<C<lexeme_read_literal()>|/"lexeme_read_literal()">
and L<C<lexeme_read_block()>|/"lexeme_read_block()"> methods.

C<lexeme_alternative()> takes up to three arguments.
The first two are, in order, C<$symbol_name> and C<$value>.
C<$symbol_name> is required
and must be the name of a symbol to be read
at the current location.
C<$value> is optional,
and specifies the value of the symbol.
If C<$value> is missing, the value of the symbol
will be a Perl C<undef>.

The fourth, optional, argument may be ignored by most applications.
It is the length of the lexeme in earlemes.
Earleme length will almost always be 1,
which is the default.
The ability to specify other earleme lengths enables
some very powerful, but advanced, techniques,
which are described
L<elsewhere|Marpa::R3::External::Low>.

The C<lexeme_alternative()> method is a non-completion method -- it adds to
the list of accepted tokens.
To be read by the parser, this list of accepted tokens
must be completed by a later call
to the C<lexeme_complete()> method.
By making two or more calls
of the C<lexeme_alternative()> method
before the next call of C<lexeme_complete()>,
an app can read an
ambiguous token.
(An ambiguous token is one which can be more than one symbol.)

When the recognizer starts,
the list of accepted tokens is empty.
The list of accepted tokens is cleared whenever C<lexeme_complete()>
is called.
It is a fatal error
if a high level scanning method is called while the list of accepted
tokens is non-empty,

C<lexeme_alternative()> has a soft failure if it rejects 
C<$symbol_name>.
All other failures are hard failures.

B<Return values>:
Returns C<undef> if the token was rejected.
On success, returns a value reserved for future use.
The value on success will not necessarily be a Perl true,
so that apps testing for rejection must test for a Perl C<undef> explicitly.
Failures are thrown as exceptions.

=head2 lexeme_alternative_literal()

=for Marpa::R3::Display
name: recognizer lexeme_alternative_literal() synopsis
partial: 1
normalize-whitespace: 1

    my $ok = $recce->lexeme_alternative_literal($symbol_name);
    die qq{Parser rejected token "$long_name" at position $start_of_lexeme, before "},
        $recce->literal( $main_block, $start_of_lexeme, 40 ), q{"}
            if not defined $ok;

=for Marpa::R3::Display::End

For advanced uses,
there is also a two-argument form:

=for Marpa::R3::Display
name: recognizer lexeme_alternative_literal() variable length synopsis
normalize-whitespace: 1

    $ok = $recce->lexeme_alternative_literal( 'A', 3 );

=for Marpa::R3::Display::End

C<lexeme_alternative_literal()> is one of the low-level methods of the external scanner.
Most applications
will prefer the simpler
L<C<lexeme_read_string()>|/"lexeme_read_string()">,
L<C<lexeme_read_literal()>|/"lexeme_read_literal()">
and L<C<lexeme_read_block()>|/"lexeme_read_block()"> methods.

C<lexeme_alternative_literal()> takes up to two arguments,
the first of which is required.
C<lexeme_alternative_literal()> and
C<lexeme_alternative()> differ from each other
only in their arguments,
and in how they set the value of the token.
For a token read by C<lexeme_alternative_literal()>,
the value of the token will be the same as its literal equivalent.
This literal equivalent
will be set by the next call to 
C<lexeme_complete()>.
Otherwise, C<lexeme_alternative_literal()> behaves in
exactly the same way as
C<lexeme_alternative()>.

The second, optional, argument may be ignored by most applications.
It is the length of the lexeme in earlemes.
Earleme length will almost always be 1,
which is the default.
The ability to specify other earleme lengths enables
some very powerful, but advanced, techniques,
which are described
L<elsewhere|Marpa::R3::External::Low>.

=head2 lexeme_complete()

=for Marpa::R3::Display
name: recognizer lexeme_complete() synopsis
partial: 1
normalize-whitespace: 1

    my $new_offset = $recce->lexeme_complete( $block_id, $offset, $length );

=for Marpa::R3::Display::End

C<lexeme_complete()> is one of the low-level methods of the external scanner.
Most applications
will prefer the simpler
L<C<lexeme_read_string()>|/"lexeme_read_string()">,
L<C<lexeme_read_literal()>|/"lexeme_read_literal()">
and L<C<lexeme_read_block()>|/"lexeme_read_block()"> methods.

Use of the low-level methods allows
the reading of ambiguous tokens.
C<lexeme_complete()>
completes the reading of a set of tokens specified by
one or more calls of the L<C<lexeme_alternative()>|/"lexeme_alternative()">
method.

The C<lexeme_complete()> method
accepts three optional arguments.
Call them, in order,
C<$block_id>, C<$offset> and C<$length>.
These specify a
L<block span|Marpa::R3::Recognizer/"Block spans">.
A zero C<$length> is acceptable.
The block span is used to set the literal equivalent for the
set of alternative tokens completed by the
C<lexeme_complete()> call.
If C<$block_id> is not defined,
the specified block is the current block.
If C<$offset> is not defined,
the specified offset is the current offset
of the specified block.
If C<$length> is not defined,
the specifed length is the
end-of-block of the specified block,
less the specified offset --
in other words, the specified block span
includes the entire remaining specified block.

C<lexeme_read_literal()> is an external scanning completion
method and, with one important difference,
the details of its behavior are
L<as described above|"High level methods in general">.
The difference is that token rejection never occurs
in C<lexeme_complete()>.
C<lexeme_complete()> relies on the app to have built a list
of accepted tokens using the
C<lexeme_alternative()>
or
C<lexeme_alternative_literal()>
calls.

It is a hard failure if C<lexeme_complete()> is called
but the list of tokens accepted by
C<lexeme_alternative()>
or
C<lexeme_alternative_literal()>
methods is empty.
All failures in C<lexeme_complete()> are hard failures.

B<Return values:>
On success, C<lexeme_complete()>
returns the new current location.
Failure is always thrown.


=head1 Copyright and License

=for Marpa::R3::Display
ignore: 1

  Copyright 2018 Jeffrey Kegler
  This file is part of Marpa::R3.  Marpa::R3 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R3 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R3.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R3::Display::End

=cut

